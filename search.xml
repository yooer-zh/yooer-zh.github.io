<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-Class</title>
    <url>/2019/11/23/ES6class/</url>
    <content><![CDATA[<h1 id="类与对象-简介"><a href="#类与对象-简介" class="headerlink" title="类与对象 - 简介"></a>类与对象 - 简介</h1><p>OOP - 面向对象开发，核心就是 封装。</p><p>只要是具有共同特征的内容，就可以看做一类。比如人类、鸟类、车类等。</p><p>类 扮演了类似工厂的角色，最后工厂生产出的就是对象。</p><h2 id="三大基本特性"><a href="#三大基本特性" class="headerlink" title="三大基本特性"></a>三大基本特性</h2><p>多态 继承 封装</p><a id="more"></a>



<p>多态：同一个接口，不同的表现。 对同一个操作用在不同的对象上会做不同的事情得到不同的结果。</p>
<h1 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h1><p>使用 <code>calss</code> 关键字，里面必须有 构造函数 <code>constructor</code></p>
<p>构造函数会在类被实例化的时候自动调用，也是第一个被调用的函数。</p>
<p><img src="/2019/11/23/ES6class/PB-Snipaste-23-16-49-348053482029.png" alt></p>
<h1 id="静态属性与静态方法"><a href="#静态属性与静态方法" class="headerlink" title="静态属性与静态方法"></a>静态属性与静态方法</h1><p>静态属性和静态方法只是类自己拥有的，不会被类实例所拥有。</p>
<p>只能通过类自己进行调用。</p>
<p>使用 <code>static</code> 关键字声明</p>
<p><img src="/2019/11/23/ES6class/PB-Snipaste-23-42-29-906059062029.png" alt></p>
<h2 id="一种静态属性-的使用场景"><a href="#一种静态属性-的使用场景" class="headerlink" title="一种静态属性 的使用场景"></a>一种静态属性 的使用场景</h2><p><img src="/2019/11/23/ES6class/PB-Snipaste-23-46-35-203052032029.png" alt></p>
<h2 id="一种静态方法-的使用场景"><a href="#一种静态方法-的使用场景" class="headerlink" title="一种静态方法 的使用场景"></a>一种静态方法 的使用场景</h2><p><img src="/2019/11/23/ES6class/PB-Snipaste-23-50-54-598055982029.png" alt></p>
<h1 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h1><p><img src="/2019/11/23/ES6class/PB-Snipaste-23-57-31-199051992029.png" alt></p>
<h1 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h1><p>类似于给属性提供钩子，在获取属性和设置属性的时候做一些额外的事。</p>
<p>在ES5中的 <code>Object.defineProperty</code> 可以做到</p>
<p><img src="/2019/11/23/ES6class/PB-Snipaste-00-22-25-467054672030.png" alt></p>
<p>ES6中变化不大，可以再class类里面使用</p>
<p><img src="/2019/11/23/ES6class/PB-Snipaste-00-23-59-275052752030.png" alt></p>
<h1 id="在ES5中模拟类"><a href="#在ES5中模拟类" class="headerlink" title="在ES5中模拟类"></a>在ES5中模拟类</h1><p>ES5中没有类的概念，但是有 构造函数 的概念。</p>
<p>构造函数：当使用 <code>new</code> 关键字调用任意一个函数的时候，这个函数就会被当做构造函数进行调用。会走构造函数的一套流程来执行这个函数。</p>
<p> <img src="/2019/11/23/ES6class/PB-Snipaste-13-13-29-125051252030.png" alt></p>
<h1 id="继承-ES6"><a href="#继承-ES6" class="headerlink" title="继承 - ES6"></a>继承 - ES6</h1><p><code>extends</code> 关键字</p>
<p><img src="/2019/11/23/ES6class/PB-Snipaste-13-26-27-604056042030.png" alt></p>
<p>非静态方法中访问super -&gt; 父类原型</p>
<p>在静态方法中访问super -&gt; 父类</p>
<p>在调用super时，父类中的this始终是子类的this</p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Promise</title>
    <url>/2019/11/21/ES6Promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise对象用于表示一个异步操作的最终状态（完成或失败）以及其返回的值。</p><p>简单地说 Promise 对象中存放着未来我们要做的事情，比如一个异步操作，等操作完成之后就会返回相应的结果，成功或失败都有相应的事情做。</p><a id="more"></a>

<h1 id="传统异步操作"><a href="#传统异步操作" class="headerlink" title="传统异步操作"></a>传统异步操作</h1><p>由于JS是单线程语言，传统的异步需要依赖于回调函数的形式。</p>
<p>但是如果出现 多层操作，即这一次的操作需要依赖于 上一次异步操作返回的数据，那么就会形成多层嵌套。</p>
<p>这时代码的维护就会变得非常困难。Promise就可以解决这种问题。</p>
<p>看一下最简单的 Promise的用法 </p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-21-19-3605362029.png" alt></p>
<h1 id="对比传统回调和Promise"><a href="#对比传统回调和Promise" class="headerlink" title="对比传统回调和Promise"></a>对比传统回调和Promise</h1><p>通过一个小例子来看</p>
<h2 id="传统回调"><a href="#传统回调" class="headerlink" title="传统回调"></a>传统回调</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-26-22-512055122029.png" alt></p>
<p>可以看到会嵌套好多层，在业务复杂的时候代码维护变得极其困难。</p>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-37-19-582055822029.png" alt></p>
<h1 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h1><p>了解</p>
<p>Promise不单单解决了毁掉地狱的问题。</p>
<p>上面的例子是：    </p>
<p>在 .then 中传递了一个函数过去，然后在一个Promise的实例中根据场合调用</p>
<p>但是在我们使用第三方库的时候，我们把自己写的回调函数交给第三方库来执行，但是无法控制第三方库会怎样处理我们的回调函数，比如会不会执行、会不会多次执行等，这就出现了 <strong>控制反转</strong>，我们把控制权交给了第三方库。</p>
<p>使用Promise可以改善这种情况，比如如果调用两次 resolve的话和调用一次效果是一样的不会出现BUG。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h3 id="then的第二个参数配合reject"><a href="#then的第二个参数配合reject" class="headerlink" title="then的第二个参数配合reject"></a>then的第二个参数配合reject</h3><p>上面介绍了Promise在异步操作成功的时候做的事情，那么错误处理呢。</p>
<p>这里需要注意： Promise判断<code>then</code>，也就是 <code>resolve</code> 和 <code>reject</code> 的时候，都是异步的！ 所以 <code>try、catch</code> 对它是没有用的。</p>
<p>处理错误的方式就是在then中除了传入 <code>resolve</code> 参数之外，再传一个 <code>reject</code> 参数，对应失败时候做的事情。</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-50-07-999059992029.png" alt></p>
<p>需要注意的是，resolve和reject 只能传入一个参数供 .then 使用，如果传入了多个就拿不到了。</p>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>这是一种错误处理方式，下面看另一种，使用 <code>catch</code>捕获错误</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-56-37-065050652029.png" alt></p>
<p>ES标准没有给到很好的无限catch的解决方案，可以持续关注</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-57-24-611056112029.png" alt></p>
<h1 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h1><p>Promise实例共有三种状态</p>
<ul>
<li>pending - 进行中</li>
<li>fulfilled - 成功</li>
<li>rejected - 失败</li>
</ul>
<p>状态只能从进行中=&gt;成功，或 进行中=&gt;失败，状态的改变称为<strong>决议</strong>，一旦决议就不能再修改。</p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>可以把多个实例重新包装成新的 promise实例。</p>
<p>接收一个数组，最后返回的也是一个promise的实例。</p>
<p>分三种情况</p>
<ol>
<li>所有promise都决议为成功，那么promise.all 就决议为成功，并把所有返回的resolve参数组合成一个数组返回，并且顺序也是一一对应的。</li>
<li>任意一个promise决议为失败，promise.all 就立即决议为失败，并且把决议失败的promise再传递出来</li>
<li>如果是空数组，promise.all 会立即决议为成功</li>
</ol>
<p>应用在 <strong>需要多个请求的数据 才能进行下一步操作的情况</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([getData1(), getData2(), getData3(), getData4()]);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">// arr 里就是上面四个方法的resolve的集合</span></span><br><span class="line">&#125;, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// 上面有一个决议失败就走这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不使用 promise.all 的话，就需要声明一个变量count计数，在每个异步操作成功后 count+1，最后再做判断。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>接收一个数组，里面也都是promise实例，不同的是</p>
<p>这么多个promise实例，一旦有一个成功了，promise.race 就会马上返回相应的promise实例，就如race竞赛的意思。</p>
<p>如果传入空数组，就会永远被挂起。</p>
<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>表示决议成功</p>
<p>在接收参数的时候有三种情况</p>
<h2 id="传递一个普通的值"><a href="#传递一个普通的值" class="headerlink" title="传递一个普通的值"></a>传递一个普通的值</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-44-56-277052772029.png" alt></p>
<h2 id="传递一个promise实例"><a href="#传递一个promise实例" class="headerlink" title="传递一个promise实例"></a>传递一个promise实例</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-47-53-3105312029.png" alt></p>
<h2 id="传递thenable对象"><a href="#传递thenable对象" class="headerlink" title="传递thenable对象"></a>传递thenable对象</h2><p>这个概念有点类似 类数组</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-51-04-381053812029.png" alt></p>
<h1 id="看一个异步例子"><a href="#看一个异步例子" class="headerlink" title="看一个异步例子"></a>看一个异步例子</h1><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-54-16-991059912029.png" alt></p>
<p>打印结果为 1 2 3 4 6 5</p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值</title>
    <url>/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值语法是一个JavaScript表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-19-08-752057522014.png" alt="PB-Snipaste-11-19-08-752057522014"></p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-20-35-697056972014.png" alt="PB-Snipaste-11-20-35-697056972014"></p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-02-265052652014.png" alt="PB-Snipaste-11-21-02-265052652014"></p><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-21-378053782014.png" alt="PB-Snipaste-11-21-21-378053782014"></p><h3 id="接收多个-函数返回值"><a href="#接收多个-函数返回值" class="headerlink" title="接收多个 函数返回值"></a>接收多个 函数返回值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-42-545055452014.png" alt="PB-Snipaste-11-21-42-545055452014"></p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-12-20-48-2605262014.png" alt="PB-Snipaste-12-20-48-2605262014"></p><h3 id="结合扩展运算符"><a href="#结合扩展运算符" class="headerlink" title="结合扩展运算符"></a>结合扩展运算符</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-01-16-777057772014.png" alt="PB-Snipaste-15-01-16-777057772014"></p><h3 id="对已经申明了的变量进行对象的解构赋值"><a href="#对已经申明了的变量进行对象的解构赋值" class="headerlink" title="对已经申明了的变量进行对象的解构赋值"></a>对已经申明了的变量进行对象的解构赋值</h3><a id="more"></a>







<p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-01-52-049050492014.png" alt="PB-Snipaste-15-01-52-049050492014"></p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-12-37-538055382014.png" alt="PB-Snipaste-15-12-37-538055382014"></p>
<h3 id="一些常用的用法"><a href="#一些常用的用法" class="headerlink" title="一些常用的用法"></a>一些常用的用法</h3><h4 id="使用对象传入乱序的函数参数"><a href="#使用对象传入乱序的函数参数" class="headerlink" title="使用对象传入乱序的函数参数"></a>使用对象传入乱序的函数参数</h4><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-20-33-402054022014.png" alt="PB-Snipaste-15-20-33-402054022014"></p>
<h4 id="获取多个-函数返回值"><a href="#获取多个-函数返回值" class="headerlink" title="获取多个 函数返回值"></a>获取多个 函数返回值</h4><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-23-02-361053612014.png" alt="PB-Snipaste-15-23-02-361053612014"></p>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-30-04-908059082014.png" alt="PB-Snipaste-15-30-04-908059082014"></p>
<h3 id="提取字符串的属性和方法"><a href="#提取字符串的属性和方法" class="headerlink" title="提取字符串的属性和方法"></a>提取字符串的属性和方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取字符串的属性或方法</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'I love my country'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; length, split &#125; = str;  <span class="comment">// length:17  split:ƒ split() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数值与布尔值的解构赋值"><a href="#数值与布尔值的解构赋值" class="headerlink" title="数值与布尔值的解构赋值"></a>数值与布尔值的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-53-15-523055232015.png" alt="PB-Snipaste-11-53-15-523055232015"></p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>见前面的例子，传入函数的参数、取多个 函数返回值。</p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6基础及let、const</title>
    <url>/2019/11/10/ES6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h1><p>ES是JS的标准，JS是ES的实现</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>JS最初由Netscape网景公司的布兰登·艾奇发明，用于解决当时网景公司的一款浏览器Navigator的用户交互问题。</p><a id="more"></a>

<p>后来网景公司想把JS标准化，就把JS交给了ECMA组织（欧洲计算机制造联合会），而且java是当时sun公司的商标，所以就使用了ECMAScript这个名字。</p>
<h2 id="ES版本的历史"><a href="#ES版本的历史" class="headerlink" title="ES版本的历史"></a>ES版本的历史</h2><ul>
<li>1998.06 - ES2发布</li>
<li><strong>1999.12 - ES3</strong>发布，成为js的通行标准，被广大浏览器支持</li>
<li>2007.10 - ES4草案发布，内容十分激进</li>
<li>2008.07 - 将ES4小部分内容提取，发布为ES3.1，后命名为ES5</li>
<li>2009.12 - ES5发布，也就是上面说的ES3.1</li>
<li>2011.06 - ES5.1发布，并成为了ISO国际标准</li>
<li>2013.03 - ES6草案冻结，不再加入新功能</li>
<li><strong>2015.06 - ES6正式通过</strong>，成为国际标准</li>
</ul>
<p>ES6又指下一代JS标准，从2015年开始用年份来标注ES6的版本号，所以ES2016、ES2017等都是属于ES6，每个新版本的内容都会依赖于之前的版本，所以这次笔记为ES2015。</p>
<h1 id="let与块级作用域"><a href="#let与块级作用域" class="headerlink" title="let与块级作用域"></a>let与块级作用域</h1><p>之前声明变量一般会使用 </p>
<ol>
<li><pre><code class="javascript"><span class="comment">// var关键字</span>
<span class="keyword">var</span> name;
<span class="keyword">var</span> age = <span class="number">18</span>;
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ol>
<p>let和var相似，也是对变量进行声明。</p>
<p>那区别呢？</p>
<h3 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h3><p>let声明的变量只在当前（块级）作用域内有效。</p>
<p>var声明的变量只在当前作用域内有效。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123111-22-16.png" alt="Snipaste_123111-22-16"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123412-23-22.png" alt="Snipaste_2020-05-13_16-23-22"></p>
<p>let声明的变量不能被重复声明。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_1245233fd14-11.png" alt="Snipaste_1245233fd14-11"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_5662sa1135-29.png" alt="Snipaste_5662sa1135-29"></p>
<p>不存在变量提升。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_55112advo213_16-38-56.png" alt="Snipaste_55112advo213_16-38-56"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123xdz11234f71-13_16-39-36.png" alt="Snipaste_123xdz11234f71-13_16-39-36"></p>
<h2 id="ES6之前的作用域"><a href="#ES6之前的作用域" class="headerlink" title="ES6之前的作用域"></a>ES6之前的作用域</h2><p>全局作用域</p>
<p>函数作用域</p>
<p>eval作用域</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>通俗的说 就是一对花括号中的区域 <code>{ ... }</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如</span></span><br><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 注意： 声明一个对象的时候，花括号就不再是块级作用域了</span></span><br></pre></td></tr></table></figure>

<p>块级作用域可以嵌套</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 块级作用域1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 块级作用域2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暂存死区"><a href="#暂存死区" class="headerlink" title="暂存死区"></a>暂存死区</h2><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_812312asd1-59-52.png" alt="Snipaste_812312asd1-59-52"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_6234sad13-13_17-00-37.png" alt="Snipaste_6234sad13-13_17-00-37"></p>
<p>ES6规定，如果块级作用域中存在 <code>let</code> <code>const</code> 声明的变量，那么一开始就会形成一个封闭的作用域。</p>
<p>简单说，即使向上的作用域中存在同名变量也是拿不到的。</p>
<h2 id="let小例子"><a href="#let小例子" class="headerlink" title="let小例子"></a>let小例子</h2><p>Q：生成10个按钮，每个按点击的时候弹出 1 - 10</p>
<h3 id="使用var实现"><a href="#使用var实现" class="headerlink" title="使用var实现"></a>使用var实现</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_213dsf3125-40.png" alt="Snipaste_213dsf3125-40"></p>
<h3 id="使用let实现"><a href="#使用let实现" class="headerlink" title="使用let实现"></a>使用let实现</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_213fsa27-29-50.png" alt="Snipaste_213fsa27-29-50"></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>用来声明常量 - 不可改变的量</p>
<p>和声明变量一样，基本只是关键字的区别</p>
<p>常量必须在声明的时候赋值，否则会报错</p>
<p>与let类似的特征</p>
<ul>
<li>不能重复声明</li>
<li>不存在提升</li>
<li>只在当前（块级）作用域内有效</li>
</ul>
<p>常量不可被修改，但是当常量为引用类型的时候，不能保证不可变</p>
<p>因为const只能保证常量指向的地址不变</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste4azd134-28-26-18.png" alt="Snipaste4azd134-28-26-18"></p>
<p>同为引用类型的数组和函数也是同样道理。</p>
<h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h2><h3 id="Q：怎么解决引用类型的常量可以被修改的问题"><a href="#Q：怎么解决引用类型的常量可以被修改的问题" class="headerlink" title="Q：怎么解决引用类型的常量可以被修改的问题"></a>Q：怎么解决引用类型的常量可以被修改的问题</h3><p>使用 <code>Object.freeeze()</code></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste1292234sad11-29.png" alt="Snipaste1292234sad11-29"></p>
<p>此函数对数组、函数同样有效。对数组使用的时候，如果修改数组会报错。</p>
<h3 id="Q：ES6之前怎么声明常量"><a href="#Q：ES6之前怎么声明常量" class="headerlink" title="Q：ES6之前怎么声明常量"></a>Q：ES6之前怎么声明常量</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_25xq2a243-13.png" alt="Snipaste_25xq2a243-13"></p>
<p>同时使用 <code>Object.defineProperty()</code> 和 <code>Object.seal()</code> 可以实现 <code>Object.freeze()</code>的效果</p>
<p>那么就来自己封装一个 <code>freeze</code>函数</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_5123asa7-53-30.png" alt="Snipaste_5123asa7-53-30"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste2677dd1353-58.png" alt="Snipaste2677dd1353-58"></p>
<p>这样就做好了一个简单的封装，但是如果遇到属性还是Obj的情况就仍然无法保证，下面改进一下</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_t234a123ad2119-03-10.png" alt="Snipaste_t234a123ad2119-03-10"></p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
  </entry>
  <entry>
    <title>GitLab搭建(docker环境)</title>
    <url>/2020/03/01/Gitlab/</url>
    <content><![CDATA[<h1 id="Gitlab优点"><a href="#Gitlab优点" class="headerlink" title="Gitlab优点"></a>Gitlab优点</h1><p>Gitlab也是一个git平台，管理仓库和项目</p><ul>
<li>现在很多Git平台对团队协作人数有限制</li>
<li>可定制化对接自动化平台Jenkins</li>
<li>可定制样式、哪些邮箱可以注册</li>
<li>可设置每个用户可以上传的文件数的大小</li>
</ul><a id="more"></a>

<h1 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h1><p>参考： <a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">官方文档</a>，找到<a href="https://docs.gitlab.com/ee/install/docker.html" target="_blank" rel="noopener">以Docker方式安装</a>。</p>
<p>可以找到最简单的一种方法来快速进行GitLab平台的测试和运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 443:443 --publish 80:80 --publish 22:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：各种参数的意义： </p>
<ul>
<li>–detach： 等同于 <code>-d</code> ，后台运行。</li>
<li>–hostname：指定域名，建议使用云服务器，域名指向IP，可以更方便的访问和迁移。也可以是虚拟机的IP。</li>
<li>–publish： 一些端口的映射，前面的数字是宿主机的端口。</li>
<li>–name gitlab：指定的镜像的名称。</li>
<li>–restart：当Docker服务重启的时候，GitLab服务自动重启。</li>
<li>–volume：Docker容器内的GitLab服务的数据映射到宿主机上。</li>
</ul>
</blockquote>
<p>下面就在虚拟机里修改一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里只做测试运行，所以删除了一些参数</span></span><br><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname 192.168.1.117 \</span><br><span class="line">  --publish 18800:80 --publish 12222:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附： 开放防火墙端口</p>
<p><code>firewall-cmd --add-port=18800/tcp --permanent</code></p>
<p><code>firewall-cmd --reload</code></p>
</blockquote>
<p>等待一下，可以通过<code>docker logs -f xxxx</code> 来实时打印gitlab的日志查看</p>
<p><em>注： 这种方法没有传入任何的username和pwd，默认用户名是root，在第一次访问的时候提示设置管理员密码。</em></p>
<p>访问页面大概长这个样子。</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-01-07-19-351043512025.png" alt="PB-Snipaste-01-07-19-351043512025"></p>
<p>但是使用 <code>docker run</code> 快速生成的gitlab服务远达不到生产的需求，比如没有HTTPS协议、SSH克隆项目的默认端口设置、邮件提示服务（merge request）、找回密码等等。</p>
<h1 id="使用docker-compose-搭建"><a href="#使用docker-compose-搭建" class="headerlink" title="使用docker-compose 搭建"></a>使用docker-compose 搭建</h1><p>同样在官方文档中有<a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" target="_blank" rel="noopener">install GitLab using docker-compose</a></p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-12-54-17-763047632025.png" alt="PB-Snipaste-12-54-17-763047632025"></p>
<p>我们选择更方便的方法</p>
<p>在github上有 <a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="noopener">docker-gitlab</a> 项目，里面有很多功能比如升级、备份、恢复、邮箱等等功能都准备好了。</p>
<p>找到项目中的 <a href="https://github.com/sameersbn/docker-gitlab/blob/master/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 文件，文件很长，我们按需设置就行了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_HOST=localhost</span>  <span class="comment"># IP地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_PORT=10080</span>  <span class="comment"># gitlab端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SSH_PORT=10022</span> <span class="comment"># SSH端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_RELATIVE_URL_ROOT=</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_ROOT_PASSWORD=</span> <span class="comment"># gitlab 密码</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_ROOT_EMAIL=</span> <span class="comment"># 管理员邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_HTTPS=false</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">SSL_SELF_SIGNED=false</span> <span class="comment"># 是否使用自签名的方式，如果是自申请的证书，则需要在gitlab加载一下证书</span></span><br></pre></td></tr></table></figure>

<p>配置好 <code>.yml</code> 文件后，就可以使用 <code>docker-compose up -d</code> ，创建运行了，创建的过程可能会持续数分钟，可以使用 <code>docker logs -f xxx</code> 来查看进度。</p>
<p>然后就可以访问服务并创建项目了。</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-35-43-379043792025.png" alt="PB-Snipaste-13-35-43-379043792025"></p>
<h1 id="GitLab平台的备份-amp-恢复"><a href="#GitLab平台的备份-amp-恢复" class="headerlink" title="GitLab平台的备份&amp;恢复"></a>GitLab平台的备份&amp;恢复</h1><h2 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h2><p>使用上述方法创建的镜像已经帮我们设置好了一个定时任务，备份的周期是天。</p>
<p>可以在 <code>.yml</code> 文件内查看到。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_BACKUP_SCHEDULE=daily</span> <span class="comment"># 周期是天</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_BACKUP_TIME=01:00</span> <span class="comment"># 在每一天01:00时备份</span></span><br></pre></td></tr></table></figure>

<h2 id="设置超期时间"><a href="#设置超期时间" class="headerlink" title="设置超期时间"></a>设置超期时间</h2><p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-52-14-579045792025.png" alt="PB-Snipaste-13-52-14-579045792025"></p>
<p>默认数值是按秒计算的，如果想要每七天设置一下超时的话，就要设置为604800秒。</p>
<p>如果不设置，backup都会被保存下来。</p>
<p>重新编辑 <code>.yml</code>文件，在如下位置添加 <code>- GITLAB_BACKUP_EXPIRY=604800</code> </p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-55-38-295042952025.png" alt="PB-Snipaste-13-55-38-295042952025"></p>
<p>这样在第八天就会自动删除第一天的备份。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新配置文件</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h2><p>在github文档中可以查到方法</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-47-19-517045172025.png" alt="PB-Snipaste-13-47-19-517045172025"></p>
<h3 id="使用docker-compose手动备份"><a href="#使用docker-compose手动备份" class="headerlink" title="使用docker-compose手动备份"></a>使用docker-compose手动备份</h3><p>使用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:create</span><br></pre></td></tr></table></figure>

<p>就备份好了。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:restore # List available backups</span><br><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:restore BACKUP=1417624827 # Choose to restore from 1417624827</span><br></pre></td></tr></table></figure>

<p>首先查看备份文件list</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-02-02-789047892025.png" alt="PB-Snipaste-14-02-02-789047892025"></p>
<p>然后将想要恢复的文件名复制粘贴进去即可</p>
<p><code>1587794387_2020_04_25_12.9.2_gitlab_backup.tar</code></p>
<p>会提示： 一旦恢复所有数据库将被覆盖，是否继续，键入yes即可。</p>
<h1 id="GitLab的权限"><a href="#GitLab的权限" class="headerlink" title="GitLab的权限"></a>GitLab的权限</h1><p>团队协作中可能出现的问题：</p>
<p>如果把所有的分支全部开放，某人误推送到了主干分支（生产分支）上了，可能会导致一些不可预期的问题。那么就进行权限控制。</p>
<h2 id="权限控制思路"><a href="#权限控制思路" class="headerlink" title="权限控制思路"></a>权限控制思路</h2><ul>
<li><p>以组为单元，设置管理员。</p>
<p>所有参与项目的人员为一个组，管理员负责项目分支的合并，管理员设置主干分支、哪些成员可以添加进来查看。</p>
</li>
<li><p>熟悉Merge Request，写好git commit。</p>
</li>
<li><p>及时回收权限，或者设置过期时间。</p>
<p>注意，回收权限时不要删除成员，只把权限回收即可。因为如果删除成员的话就会把他的历史提交一并删除掉，无法溯源。</p>
</li>
</ul>
<p>建议的角色分配</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-21-31-353043532025.png" alt="PB-Snipaste-14-21-31-353043532025"></p>
<h2 id="组管理-amp-组权限"><a href="#组管理-amp-组权限" class="headerlink" title="组管理&amp;组权限"></a>组管理&amp;组权限</h2><p>GitLab的组类似GitHub上组织的概念</p>
<p>比如来了一个 <code>frontend-group1</code> 项目组，</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-24-44-3404342025.png" alt="PB-Snipaste-14-24-44-3404342025"></p>
<p>然后就可以设置组权限，注意这里设置的权限是针对所有项目的权限，和之前的项目权限做区分。</p>
<h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 项目 - 设置 - 仓库 - Protected Branches 中设置受保护的分支、允许推送和合并的Roles。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Sass</title>
    <url>/2020/02/10/Sass/</url>
    <content><![CDATA[<h1 id="Sass基础"><a href="#Sass基础" class="headerlink" title="Sass基础"></a>Sass基础</h1><h2 id="Sass整体介绍"><a href="#Sass整体介绍" class="headerlink" title="Sass整体介绍"></a>Sass整体介绍</h2><p>官网介绍Sass是CSS扩展语言。Sass是基于Ruby语言开发的。</p><p>CSS预处理工具。</p><p>需要前置文件，然后进行编译解析，最后生成CSS。</p><p> <img src="/2020/02/10/Sass/image-20191219145953928.png" alt></p><ul>
<li><p>嵌套规则</p>
<p>通过花括号的方式解决复杂的css父子样式嵌套问题。</p>
</li>
<li><p>变量规则</p>
<p>通过变量将公共样式抽离，减少冗余css代码。</p>
</li>
<li><p>条件逻辑</p>
<p>向高级语言一样编写逻辑性的css代码</p>
</li>
</ul><a id="more"></a>




<h1 id="Sass基础知识"><a href="#Sass基础知识" class="headerlink" title="Sass基础知识"></a>Sass基础知识</h1><h2 id="变量和引用"><a href="#变量和引用" class="headerlink" title="变量和引用"></a>变量和引用</h2><ul>
<li><p>定义</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规类型</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="comment">// 颜色类型</span></span><br><span class="line"><span class="variable">$color</span>: <span class="number">#e03434</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default语法</span></span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">100px</span>;  <span class="comment">// 如果这么写，200就会被100覆盖掉</span></span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">100px</span> default;  <span class="comment">// 加上default语法的话，100就变成了默认值，其他地方可以把这个值覆盖掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="variable">$str</span>: <span class="string">'hello.jpeg'</span>;  <span class="comment">// 加引号的字符串</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>-<span class="selector-tag">img</span>: url(<span class="string">'./img/'</span>+<span class="variable">$str</span>);  <span class="comment">// 字符串可以拼接，使用+</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$strNoQout</span>: abc;  <span class="comment">// 也可以正常使用</span></span><br><span class="line"><span class="comment">// 字符串连接，插值变量的语法</span></span><br><span class="line"><span class="attribute">background</span>-<span class="selector-tag">img</span>: url(<span class="string">'./img/#&#123;$strNoQout'</span>&#125;);  <span class="comment">// #&#123;&#125;</span></span><br><span class="line"><span class="comment">// 插值变量还可以用在很多地方</span></span><br><span class="line"><span class="variable">$class</span>: <span class="string">'.div'</span>;</span><br><span class="line">#&#123;<span class="variable">$class</span>&#125;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#ffe932</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$widthInner</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$widthInner</span>;  <span class="comment">// 这里不会报错，可以找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$widthInner</span>;  <span class="comment">// 这里会报错，找不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>import</p>
<p>css原生在每次import的时候都需要发送请求，不友好不推荐使用。</p>
<p>sass的import是在编译的时候一起编译。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了和css原生的import区分开，sass约定，满足一下四个条件中的任何一个，sass在编译的时候就不会编译成sass特有的语法</span></span><br><span class="line"><span class="comment">1. import的是以 .css结尾的名字</span></span><br><span class="line"><span class="comment">2. import的是以 http:// 开头的</span></span><br><span class="line"><span class="comment">3. 使用url()包裹的</span></span><br><span class="line"><span class="comment">4. 引入任何 media queries 的样式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'.org.css'</span>;  <span class="comment">// 这种形式会认为是css原生的import</span></span><br><span class="line">$width: <span class="number">300</span>px;</span><br><span class="line">$color: #ffe932;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在sass中约定，将想要引入的文件以下划线_开头，在引入的时候把 下划线和扩展名 去掉。</span></span><br><span class="line"><span class="comment">// 新建 _base.sass 文件</span></span><br><span class="line">@<span class="keyword">import</span> base;  <span class="comment">// 去掉 下划线和扩展名 引入。</span></span><br><span class="line">$width: <span class="number">300</span>px;</span><br><span class="line">$color: #ffe932;</span><br></pre></td></tr></table></figure>

<p>import的位置不同，可能会出现声明的变量被覆盖的情况，如果想避免这种情况，就可以使用default生命方式，所以被引入的文件中的变量如果使用default方式声明的话，就不需要担心了。</p>
</li>
</ul>
<h1 id="Sass数据类型"><a href="#Sass数据类型" class="headerlink" title="Sass数据类型"></a>Sass数据类型</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$zoomValue</span>: <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// color</span></span><br><span class="line"><span class="variable">$color</span>: red;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#ffe932</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="variable">$str</span>: <span class="string">'hello.jpeg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="variable">$list</span>: (<span class="number">100px</span>, <span class="number">200px</span>, <span class="number">300px</span>, <span class="number">400px</span>, <span class="number">2</span>, <span class="string">'string'</span>);</span><br><span class="line"><span class="comment">// list 的常见用法</span></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: nth(<span class="variable">$list</span>, <span class="number">1</span>);  <span class="comment">// nth方法 提取到了list的第1个元素，而且下标是从1开始的。</span></span><br><span class="line">    <span class="attribute">height</span>: nth(<span class="variable">$list</span>, <span class="number">2</span>);</span><br><span class="line">    zoom: nth(<span class="variable">$list</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index 找到指定元素的数字下标</span></span><br><span class="line">index($list, 'string');  // 6</span><br><span class="line"></span><br><span class="line"><span class="comment">// map  类似对象</span></span><br><span class="line"><span class="variable">$map</span>: (top: <span class="number">1px</span>, left: <span class="number">2px</span>, bottom: <span class="number">3px</span>, right: <span class="number">4px</span>);</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: map-get(<span class="variable">$map</span>, top);  <span class="comment">// 使用map-get 方法，传入key获取value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="keyword">@each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$map</span> &#123;  <span class="comment">// 把map遍历一下，然后依次把key作为属性，value作为值</span></span><br><span class="line">        #&#123;<span class="variable">$key</span>&#125;: <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass基本运算"><a href="#Sass基本运算" class="headerlink" title="Sass基本运算"></a>Sass基本运算</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num1</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="variable">$num2</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$width</span>: <span class="variable">$num1</span> + <span class="variable">$num2</span>;  <span class="comment">// 加</span></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加减乘除</span></span><br><span class="line"><span class="attribute">font</span>: (<span class="number">10px</span> / <span class="number">8</span>);  <span class="comment">// 除法， 1.5px</span></span><br><span class="line"><span class="attribute">font</span>: (<span class="number">10px</span> * <span class="number">8</span>);  <span class="comment">// 乘法, </span></span><br><span class="line"><span class="attribute">width</span>: <span class="variable">$width</span> / <span class="number">2</span>;  <span class="comment">// 使用变量就不需要加括号了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色运算</span></span><br><span class="line"><span class="variable">$color1</span>: <span class="number">#010203</span>;</span><br><span class="line"><span class="variable">$color2</span>: <span class="number">#040506</span>;</span><br><span class="line"><span class="variable">$color3</span>: <span class="number">#a69e61</span>;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$color1</span> + <span class="variable">$color2</span>;  <span class="comment">// 会警告，直接颜色相加的方式已经过期，后期可能会废弃，建议使用color方法   结果： #050509，是对每一位进行相加</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">color</span>: mix(<span class="variable">$color1</span>, <span class="variable">$color2</span>);  <span class="comment">// 混合色， #030405</span></span><br><span class="line">    <span class="attribute">color</span>: red(<span class="variable">$color3</span>);  <span class="comment">// 166</span></span><br><span class="line">    <span class="attribute">color</span>: green(<span class="variable">$color3</span>);  <span class="comment">// 158</span></span><br><span class="line">    <span class="attribute">color</span>: blue(<span class="variable">$color3</span>);  <span class="comment">// 97</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串运算</span></span><br><span class="line">$str = 'hello.jpeg';</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'images/'</span>+<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin 语法块</span></span><br><span class="line"><span class="comment">// 一般的mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> helloMixin &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        size: <span class="number">20px</span>;</span><br><span class="line">        weight: <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套mixin 一定要注意是否使用了相同的属性</span></span><br><span class="line"><span class="keyword">@mixin</span> helloMixin2 &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        size: <span class="number">20px</span>;</span><br><span class="line">        weight: <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> sexy-border(<span class="variable">$color</span>, <span class="variable">$width</span>)&#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        color: <span class="variable">$color</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="selector-tag">style</span>: dashed;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="variable">$include</span> sexy-<span class="attribute">border</span>(blue, 2px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass继承-extend"><a href="#Sass继承-extend" class="headerlink" title="Sass继承  @extend"></a>Sass继承  @extend</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单继承</span></span><br><span class="line">.div &#123;</span><br><span class="line">    border: <span class="number">1</span>px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.divext &#123;</span><br><span class="line">    @extend .div;</span><br><span class="line">    border-width: <span class="number">3</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联属性继承</span></span><br><span class="line">.div1 &#123;</span><br><span class="line">    border: <span class="number">1</span>px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.div1.other &#123;</span><br><span class="line">    background-image: url(<span class="string">'hello.jpeg'</span>);</span><br><span class="line">&#125;</span><br><span class="line">.divext &#123;</span><br><span class="line">    @extend .div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式继承</span></span><br><span class="line">.div1 &#123;</span><br><span class="line">    border: 1px soild #000;</span><br><span class="line">&#125;</span><br><span class="line">.div2 &#123;</span><br><span class="line">    @extend .div1;</span><br><span class="line">    color: #red;</span><br><span class="line">&#125;</span><br><span class="line">.div3 &#123;</span><br><span class="line">    @extend .div2;</span><br><span class="line">    color: #000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链式继承中，相同的属性名是不会合并的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪类继承</span></span><br><span class="line">a:hover &#123;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    @extend :hover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 效果：</span></span><br><span class="line">a:hover, a.hoverlink &#123;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass嵌套"><a href="#Sass嵌套" class="headerlink" title="Sass嵌套"></a>Sass嵌套</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过括号的层级让代码更清晰</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.div-inner</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.div-inner-inner</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种嵌套方法： css中以横杠- 隔开的属性都可以用mixin的方式写</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.div-inner</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: &#123;</span><br><span class="line">            left: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="attribute">background</span>: &#123;</span><br><span class="line">            image: url(<span class="string">'abc.png'</span>);</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass的条件控制语句"><a href="#Sass的条件控制语句" class="headerlink" title="Sass的条件控制语句"></a>Sass的条件控制语句</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line">$type = 'tony';</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$type</span> == <span class="string">'bufy'</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if type == <span class="string">'tim'</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if <span class="variable">$type</span> == <span class="string">'tony'</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@if</span> <span class="variable">$type</span> == <span class="string">'bufy'</span> &#123;</span><br><span class="line">    <span class="selector-class">.div</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="selector-class">.div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;  <span class="comment">// through 可以改为 to，使用through的话包括3，to知道2 </span></span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 效果</span></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for list</span></span><br><span class="line"><span class="variable">$list</span>: (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> to length(list) &#123;</span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$i</span>: <span class="variable">$i-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>sass：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194025755.png" alt></p>
<p>css：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194034623.png" alt></p>
<h1 id="Sass内置函数"><a href="#Sass内置函数" class="headerlink" title="Sass内置函数"></a>Sass内置函数</h1><h2 id="number函数"><a href="#number函数" class="headerlink" title="number函数"></a>number函数</h2><p> <img src="/2020/02/10/Sass/image-20200303194153328.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194241320.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194303377.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194317185.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194331151.png" alt></p>
<p>sass：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194849896.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194820090.png" alt></p>
<p>css：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194908607.png" alt></p>
<h2 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h2><p> <img src="/2020/02/10/Sass/image-20200303194736306.png" alt></p>
<h2 id="str函数"><a href="#str函数" class="headerlink" title="str函数"></a>str函数</h2><p> <img src="/2020/02/10/Sass/image-20200303195258931.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303195434044.png" alt></p>
<h2 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h2><p> <img src="/2020/02/10/Sass/image-20200303195812958.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200329863.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200339446.png" alt></p>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p> <img src="/2020/02/10/Sass/image-20200303200758016.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200810926.png" alt></p>
]]></content>
      <categories>
        <category>前端
- CSS</category>
      </categories>
  </entry>
  <entry>
    <title>Docker快速上手</title>
    <url>/2020/01/20/docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="/2020/01/20/docker/docker01.png" alt="img"></p><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a>


<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<p>docker技术主要应用在<strong>容器化应用</strong>上。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-12-31-52-403044032023.png" alt="PB-Snipaste-12-31-52-403044032023"></p>
<h1 id="docker虚拟技术和传统虚拟机区别"><a href="#docker虚拟技术和传统虚拟机区别" class="headerlink" title="docker虚拟技术和传统虚拟机区别"></a>docker虚拟技术和传统虚拟机区别</h1><p><img src="/2020/01/20/docker/PB-Snipaste-12-39-01-539045392023.png" alt="PB-Snipaste-12-39-01-539045392023"></p>
<h1 id="docker主要特性"><a href="#docker主要特性" class="headerlink" title="docker主要特性"></a>docker主要特性</h1><ul>
<li>文件、资源、网络隔离</li>
<li><strong>变更管理</strong>、日志记录</li>
<li><strong>写时复制</strong>的方式创建的根文件系统</li>
</ul>
<h1 id="docker安装演示"><a href="#docker安装演示" class="headerlink" title="docker安装演示"></a>docker安装演示</h1><p>环境：</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-12-58-02-728047282023.png" alt="PB-Snipaste-12-58-02-728047282023"></p>
<h2 id="删除之前安装过的docker"><a href="#删除之前安装过的docker" class="headerlink" title="删除之前安装过的docker"></a>删除之前安装过的docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure>

<h2 id="添加stable的Docker-ce源"><a href="#添加stable的Docker-ce源" class="headerlink" title="添加stable的Docker-ce源"></a>添加stable的Docker-ce源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>使用 <code>systemctl start docker</code> 运行起docker来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>查看docker进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/20/docker/PB-Snipaste-13-18-19-128041282023.png" alt="PB-Snipaste-13-18-19-128041282023"></p>
<h2 id="第一个docker应用-hello-world"><a href="#第一个docker应用-hello-world" class="headerlink" title="第一个docker应用 - hello-world"></a>第一个docker应用 - hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/20/docker/PB-Snipaste-13-22-58-499044992023.png" alt="PB-Snipaste-13-22-58-499044992023"></p>
<h2 id="使用docker中国官方镜像加速"><a href="#使用docker中国官方镜像加速" class="headerlink" title="使用docker中国官方镜像加速"></a>使用docker中国官方镜像加速</h2><p>编辑 <code>/etc/docker/daemon.json</code> ，没有就创建改文件</p>
<p>添加以下内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"registry-mirrors"</span> : [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启 daemon和docker进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p><em>附： ubuntu上可以使用 <code>service docker restart</code></em> 重启docker镜像</p>
<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><ul>
<li><p><code>docker ps</code> 查看正在运行的容器</p>
</li>
<li><p><code>docker ps -a</code> 查看所有容器</p>
</li>
<li><p><code>docker stop &lt;id/name&gt;</code> 停止容器</p>
</li>
<li><p><code>docker rm &lt;id/name&gt;</code> 删除一个已经停止的容器</p>
<p><em>注：正在运行的容器是无法删除的</em></p>
</li>
<li><p><code>docker logs -f &lt;id/name&gt;</code>  打印log -f表示持续打印</p>
</li>
<li><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code> 在运行的容器中执行命令</p>
<ul>
<li><strong>-d :</strong>分离模式: 在后台运行</li>
<li><strong>-i :</strong>即使没有附加也保持STDIN 打开</li>
<li><strong>-t :</strong>分配一个伪终端</li>
</ul>
<p><em>附：进入docker容器 <code>docker exec -i -t  &lt;id/name&gt;/bin/bash</code></em></p>
</li>
</ul>
<h2 id="安装mysql的docker容器"><a href="#安装mysql的docker容器" class="headerlink" title="安装mysql的docker容器"></a>安装mysql的docker容器</h2><p>进入 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>， 找到mysql容器的安装方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure>

<p>替换一些参数，自定义一下容器名和密码，这里缺省了 <code>:tag</code> ，就会默认拉取最新的镜像，也可以将<code>tag</code> 设置为想要拉取的版本，参数 <code>-d</code> 意思是后台运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zy-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>

<p>然后可以使用 docker ps 查看下载好的镜像了</p>
<h3 id="映射mysql服务的端口号-p"><a href="#映射mysql服务的端口号-p" class="headerlink" title="映射mysql服务的端口号 -p"></a>映射mysql服务的端口号 <code>-p</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zy-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 23457:3306 -d mysql</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>-p</code>参数后跟着的 <code>23457:3306</code> ，前面的数字代表 外部（宿主机）端口，后面的数字代表docker内部的端口</p>
<h2 id="进入容器看一眼"><a href="#进入容器看一眼" class="headerlink" title="进入容器看一眼"></a>进入容器看一眼</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it zy-mysql /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="退出docker容器"><a href="#退出docker容器" class="headerlink" title="退出docker容器"></a>退出docker容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p>一个场景：当我们有多个docker容器需要统一管理的时候，难道要一个个的run、stop吗？</p>
<p>显然这样操作太繁琐。</p>
<p>这时就需要一个集成工具，来帮我们统一管理多个docker镜像，查看、启动、停止等。</p>
<p>使用一个 <code>.yml</code> 文件来统一管理。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-16-04-18-727047272024.png" alt="PB-Snipaste-16-04-18-727047272024"></p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 给予执行权限</span></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：安装后执行docker-compose提示 <a href="https://blog.csdn.net/alen_xiaoxin/article/details/104849962" target="_blank" rel="noopener">Cannot open self /usr/local/bin/docker-compose or archive /usr/local/bin/docker-compoe.pkg解决办法</a></p>
</blockquote>
<h2 id="编辑-docker-compose-yml-文件"><a href="#编辑-docker-compose-yml-文件" class="headerlink" title="编辑 docker-compose.yml 文件"></a>编辑 docker-compose.yml 文件</h2><p>这里演示启动两个 mysql服务，<code>mysql1</code> 和 <code>mysql2</code></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-38-50-639046392024.png" alt="PB-Snipaste-17-38-50-639046392024"></p>
<p><em>附： 上图有语法错误，line8、15 的 <code>-</code> 后面应有一个空格</em></p>
<h2 id="批量启动镜像"><a href="#批量启动镜像" class="headerlink" title="批量启动镜像"></a>批量启动镜像</h2><p>然后就可以使用 <code>docker-compose up -d</code> 根据 <code>.yml</code>文件配置来创建两个容器了</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-52-35-335043352024.png" alt="PB-Snipaste-17-52-35-335043352024"></p>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>使用<code>docker-compose stop</code> 批量停止</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-59-08-911049112024.png" alt="PB-Snipaste-17-59-08-911049112024"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>docker-compose rm</code></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-59-56-488044882024.png" alt="PB-Snipaste-17-59-56-488044882024"></p>
<h1 id="使用Docker-hub-提交、拉取自己的镜像"><a href="#使用Docker-hub-提交、拉取自己的镜像" class="headerlink" title="使用Docker hub 提交、拉取自己的镜像"></a>使用<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a> 提交、拉取自己的镜像</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>使用 <code>docker login</code> 可以登录自己的docker账号，然后就可以提交和拉取了</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-04-21-3604362024.png" alt="PB-Snipaste-18-04-21-3604362024"></p>
<h2 id="创建image"><a href="#创建image" class="headerlink" title="创建image"></a>创建image</h2><p>使用 <code>docker commit 57d92a983a62（容器id） &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code> 来创建镜像</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-08-26-511045112024.png" alt="PB-Snipaste-18-08-26-511045112024"></p>
<p>使用 <code>docker images</code> 看一眼自己的镜像</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-09-50-903049032024.png" alt="PB-Snipaste-18-09-50-903049032024"></p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p><code>docker push &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code></p>
<p>有一些已经存在远端的文件就会 Mounted ，不会再次推送，节约了推送的时间。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-12-00-167041672024.png" alt="PB-Snipaste-18-12-00-167041672024"></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-15-18-227042272024.png" alt="PB-Snipaste-18-15-18-227042272024"></p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>推送成功后可以在随意一台机器上使用 <code>docker pull &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code> 拉取镜像了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深入理解</title>
    <url>/2019/01/20/JavaScript%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<h1 id="JavaScript深入"><a href="#JavaScript深入" class="headerlink" title="JavaScript深入"></a>JavaScript深入</h1><p>什么是变量？</p><p>数据：数字、字符串、布尔、对象、数组等都是数据</p><p>只使用一次的话可以直接用</p><p>多次使用的情况就会使用容器保存，这个容器也就是变量。</p><p>变量的命名：</p><p>由<code>$ _ 字母 数字</code>组成，不能以数字开头。</p><a id="more"></a>





<p>不能使用已保留的关键字： <code>if for ...</code></p>
<p>不能使用保留字：<code>class ...</code></p>
<p>单词间的连接： 以<code>_</code> 连接或者驼峰形式。</p>
<p>声明：</p>
<p><code>var</code> 如果在声明的同时不赋值的话，默认就会赋值undefined。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>数字number</p>
<p>字符串string</p>
<p>布尔bool</p>
<p>undefined</p>
<p>null</p>
<p>基本类型的值是不可以修改的，只能覆盖</p>
<p>也就是说，所有关于字符串的操作都是返回一个字符串，而不会直接修改字符串</p>
<p>基本类型是无法添加属性的，这里解释:<code>&#39;string&#39;.replace</code></p>
<p>为什么基本类型string可以使用replace方法？ 是因为当基本类型调用方法的时候，会寻找它的包装对象String，使用的是包装对象的方法。</p>
<p>基本类型不可修改，大小不变，也就保存在<strong>栈内存</strong>中。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>数组array</p>
<p>对象object</p>
<p>引用类型的值是可以修改的</p>
<p>引用类型可修改，大小不固定，只能保存在堆内存中。</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>数据保存在硬盘上，在使用的时候会放在内存上。</p>
<p>又分为 堆内存、栈内存。</p>
<p><strong>栈内存</strong>会分成几块地址，是有序的，但是大小是固定的。</p>
<p><strong>堆内存</strong>里面是无序排列，大小不固定。</p>
<p>堆内存中存储的数据因为位置不固定所以不好找，所以需要明确它们的地址，地址是固定的大小，所以地址可以存储在栈内存中，就可以轻松找到引用对象了。</p>
<h3 id="变量比较"><a href="#变量比较" class="headerlink" title="变量比较"></a>变量比较</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本变量间的比较</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">a === b;  <span class="comment">// true 全等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用变量的比较</span></span><br><span class="line"><span class="keyword">var</span> vm = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    score: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xh = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    score: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">vm === xh;  <span class="comment">// false 指向不同的空间所以不相等，引用对象只有指向相同空间的时候才相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只想知道长的是不是一样</span></span><br><span class="line"><span class="comment">// 需要通过遍历比较内容才知道</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equalObjs</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p]!==b[p]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组的比较</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equalArrays</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length != b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!==b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制变量的值"><a href="#复制变量的值" class="headerlink" title="复制变量的值"></a>复制变量的值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a === b;  <span class="comment">// true</span></span><br><span class="line">a++;</span><br><span class="line">b;  <span class="comment">// 4  基本类型的值的复制，两个值互不干涉，只是复制。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xm = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    score: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xh = xm;</span><br><span class="line">xh.score++;</span><br><span class="line">xh.score;  <span class="comment">// 5</span></span><br><span class="line">xm.score;  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 因为两个变量指向相同，所以一个变，另一个也会跟着变。</span></span><br></pre></td></tr></table></figure>

<p>所以如果想复制一个 引用对象，又可以像 基本类型一样，只是复制，互不干涉的话：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        newObj[p] = obj[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也就是浅拷贝，深拷贝需要递归知识</span></span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="基本类型传递参数"><a href="#基本类型传递参数" class="headerlink" title="基本类型传递参数"></a>基本类型传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> score = <span class="number">10</span>;</span><br><span class="line">addTen(score);</span><br><span class="line"><span class="comment">// 基本类型传递参数，相当于 num = score，两者没有什么关系。</span></span><br></pre></td></tr></table></figure>

<h3 id="引用类型传递参数"><a href="#引用类型传递参数" class="headerlink" title="引用类型传递参数"></a>引用类型传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">Obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.name = <span class="string">'xm'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">setName(person);  <span class="comment">// 传的其实是地址，按值传递，没有按引用访问</span></span><br><span class="line">person.name;  <span class="comment">//  vm</span></span><br></pre></td></tr></table></figure>

<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><h4 id="基本类型的检测"><a href="#基本类型的检测" class="headerlink" title="基本类型的检测"></a>基本类型的检测</h4><p><code>typeof / typeof()</code></p>
<h4 id="引用类型的检测"><a href="#引用类型的检测" class="headerlink" title="引用类型的检测"></a>引用类型的检测</h4><p><code>[] instanceof Array</code> Array 是构造函数</p>
<p>instanceof 只能和引用类型连用，不能和基本类型连用</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量起作用的区域、范围</p>
<ol>
<li>变量的生命周期</li>
<li>可以访问到变量的区域<ul>
<li>全局作用域</li>
<li>局部作用域</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;  <span class="comment">// 全局作用域（全局变量）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sex = <span class="string">'male'</span>;  <span class="comment">// 局部作用域/函数作用域（局部变量）</span></span><br><span class="line">    <span class="built_in">console</span>.log(sex);  <span class="comment">// 可以访问到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sex);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>JavaScript中没有块级作用域，所以在if、for的块中定义的变量也是全局变量。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>全局空间中做主的是window对象，也就是全局变量的变量对象，所有全局空间中的属性和函数，都是window对象的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sex = <span class="string">'male'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name 就是 window.name</span></span><br><span class="line"><span class="comment">fn   就是 windo.fn</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部作用域的变量对象看不见摸不着，js引擎在后台运行会使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 访问不存在的属性也不会报错，而是会显示undefined</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链主要是为了查找变量引出的</p>
<p>函数作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'xh'</span>;</span><br><span class="line">    <span class="keyword">var</span> sex = <span class="string">'male'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'xhei'</span>;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在一个作用域中使用变量时，会沿着作用域链进行，优先在当前作用域中查找，找到的话就不在往外找，找不到就会往外找。</p>
<p>也就是说，同名的变量越往内优先级越高。</p>
<p>而且当前局部作用域的查找速度会快于外部作用域</p>
<p>所以jQuery的代码，会把window对象作为一个参数传入到函数里面，而不是直接使用，速度会更快，而且方便压缩代码。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'xm'</span>;</span><br><span class="line">person.sex = <span class="string">'male'</span>;</span><br><span class="line"><span class="keyword">var</span> score = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// xm</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sex);  <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(score);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(person)&#123;  <span class="comment">// 尽量不要使用with</span></span><br><span class="line">    name = <span class="string">'xh'</span>;</span><br><span class="line">    sex = <span class="string">'female'</span>;</span><br><span class="line">    score = <span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// xh</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sex);  <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(score);  <span class="comment">// 44</span></span><br></pre></td></tr></table></figure>

<h2 id="JS解析机制"><a href="#JS解析机制" class="headerlink" title="JS解析机制"></a>JS解析机制</h2><ol>
<li><p>预解析</p>
<p>分别在各个作用域里进行预解析，先在window中预解析。预解析的时候就会给赋值undefined。</p>
</li>
<li><p>逐行解析</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);  <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'xh'</span>;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 在某些火狐老版本的浏览器中，js预解析无法解析到if、for 块里面的代码，所以函数尽量不要声明在if、for的块里面。</p>
<h2 id="垃圾收集机制"><a href="#垃圾收集机制" class="headerlink" title="垃圾收集机制"></a>垃圾收集机制</h2><p>释放无用的数据，回收内存。分为自动收集、手动收集。</p>
<p>原理：找出没用的数据，打上标记，释放其内存；周期性执行。</p>
<p>标识无用数据的策略</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>垃圾收集器在运行时，会给内存中的所有变量一次性全加上标记，然后会去掉环境中的变量（还在环境中的变量），以及被环境中变量所引用的变量的标记。</p>
<p>目前几乎所有的浏览器垃圾回收都是用的标记清除的方式，只不过时间间隔有区别。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>每次有变量引用值的时候，这个值的引用计数就+1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xm = &#123;</span><br><span class="line">    name: <span class="string">'xm'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> xh = xm;  <span class="comment">// 2</span></span><br><span class="line">xh = &#123;&#125;;  <span class="comment">// 1</span></span><br><span class="line">xm = &#123;&#125;;  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>但是引用计数会有循环引用的现象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xm = &#123;&#125;;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> xh = &#123;&#125;;  <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// xm、xh都是局部变量，所以执行完一次以后就会被销毁</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">xm = <span class="literal">null</span>;  <span class="comment">//0</span></span><br><span class="line">xh = <span class="literal">null</span>;  <span class="comment">//0</span></span><br><span class="line"><span class="comment">/*  -----------------------------------------------  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xm = &#123;&#125;;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">var</span> xh = &#123;&#125;;  <span class="comment">// 1</span></span><br><span class="line">    </span><br><span class="line">    xm.wife = xh;  <span class="comment">// 2</span></span><br><span class="line">    xh.husband = xm;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">xm = <span class="literal">null</span>;  <span class="comment">// 1</span></span><br><span class="line">xh = <span class="literal">null</span>;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>IE9 之前的浏览器版本</p>
<p>JS: DOM和BOM</p>
<p>IE9之前的浏览器的DOM和BOM对象不是原生的，而是通过C++在COM对象的基础上实现的，COM对象的实现就采用的引用计数的垃圾回收机制，所以即使IE老版本浏览器JS引擎使用的是标记清除的策略，但是因为COM，所以还是可能会出现循环引用的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;  <span class="comment">// 原生对象，标记清除策略</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);  <span class="comment">// DOM元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么下面还是会出现循环引用的问题</span></span><br><span class="line">elem.someAttr = obj;</span><br><span class="line">obj.someProperty = elem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决方法</span></span><br><span class="line">elem.someAttr = <span class="literal">null</span>;</span><br><span class="line">obj.someProperty = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>操作系统在分配内存时，Web浏览器 &lt; 桌面应用程序。</p>
<p>对用不到的数据，设置为null，解除引用，马上释放内存。</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>对象就是任意值的集合</p>
<p>JS中的值有 字符串、布尔、数组、函数、对象，都是值，也都可以用来构成对象。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Tom'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">'family'</span>: [<span class="string">"did"</span>, <span class="string">"mother"</span>],</span><br><span class="line">    <span class="string">'speak'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 对象中的函数叫做方法，方法也是对象的属性，只不过别名叫方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"喵喵"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'friend'</span>: &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'Jerry'</span>,</span><br><span class="line">        <span class="string">'age'</span>: <span class="number">4</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  <span class="comment">// 键值对就是对象的一个属性，属性名： 属性值</span></span><br><span class="line"><span class="comment">// 这样只使用一个全局变量就可以了，可以防止全局变量冲突</span></span><br></pre></td></tr></table></figure>

<p>另一种创建方法： 构造函数 <code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 相当于 var cat = &#123;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>ES5中新增的创建方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create();  <span class="comment">// 有兼容性问题，作为了解</span></span><br></pre></td></tr></table></figure>

<h2 id="读取、设置-属性"><a href="#读取、设置-属性" class="headerlink" title="读取、设置 属性"></a>读取、设置 属性</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取属性有两种方法，通过点、通过方括号</span></span><br><span class="line">cat.name;</span><br><span class="line">cat[<span class="string">"name"</span>];</span><br><span class="line"><span class="comment">// 赋值也有两种方法，通过点、通过方括号</span></span><br><span class="line">cat.name = <span class="string">"Tim"</span>;</span><br><span class="line">cat[<span class="string">"name"</span>] = <span class="string">"Tim"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="删除-属性-delete"><a href="#删除-属性-delete" class="headerlink" title="删除 属性 delete"></a>删除 属性 delete</h2><p>delete</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> cat.type;</span><br></pre></td></tr></table></figure>

<h2 id="判断是否有属性-in"><a href="#判断是否有属性-in" class="headerlink" title="判断是否有属性 in"></a>判断是否有属性 in</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> cat;  <span class="comment">// 返回布尔类型的值</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>for in 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> cat)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">    <span class="comment">// 下面就是 点语法 和 方括号语法 的区别。</span></span><br><span class="line">    <span class="built_in">console</span>.log(cat.p);  <span class="comment">// 这么写是错的，p就变成了属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(cat[p]);  <span class="comment">// 正确写法，这里就会先计算p的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>一次定义，多处调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的调用</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">`function`关键字会告诉JS的解析器（浏览器），我是函数。</span></span><br><span class="line"><span class="comment">add 是函数名，函数保存在内存中，需要使用标识符找到这个函数，也就是函数名，没有名字的函数叫做匿名函数。</span></span><br><span class="line"><span class="comment">花括号里面的内容就是函数体，用来封装代码，函数体里就是一个局部作用域。</span></span><br><span class="line"><span class="comment">return： 函数结束的标志、返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="定义和调用时发生了什么"><a href="#定义和调用时发生了什么" class="headerlink" title="定义和调用时发生了什么"></a>定义和调用时发生了什么</h2><p>定义函数的时候，函数体里的代码不会执行，只是封装，只有当调用的时候，代码才会执行。</p>
<p>浏览器环境下，全局变量是<code>Window</code></p>
<ol>
<li>函数定义以后，会在window节点下增加了add方法</li>
<li>函数调用以后，会在add下创建局部作用域，里面有<code>num1</code>、<code>num2</code>，然后开始赋值，把实参赋值给形参。</li>
<li>函数执行完毕后，会将创建的局部作用域连同局部变量销毁掉，但是add节点是不会销毁的，所以可以进行多次的执行（调用），每次调用都会重新创建局部作用域。</li>
</ol>
<h2 id="为什么要使用函数"><a href="#为什么要使用函数" class="headerlink" title="为什么要使用函数"></a>为什么要使用函数</h2><ol>
<li>代码复用。</li>
<li>统一修改和维护。</li>
<li>可读性好，化繁为简。</li>
</ol>
<h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><ol>
<li><p>可调用性</p>
</li>
<li><p>函数也是对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>, <span class="string">'num2'</span>, ..)</span><br></pre></td></tr></table></figure>

<p>函数也可以添加属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">add.sex = <span class="string">'male'</span>;</span><br><span class="line">add.setSex = <span class="function"><span class="keyword">function</span>(<span class="params">sex</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add.sex);  <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(add.setSex(<span class="string">'famale'</span>));  <span class="comment">// undefinded</span></span><br><span class="line"><span class="built_in">console</span>.log(add.sex);  <span class="comment">// female</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为数据值使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="built_in">console</span>.log(add());  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add);  <span class="comment">// 函数本体</span></span><br></pre></td></tr></table></figure>

<p>在数组、对象中也可以存函数</p>
</li>
<li><p>作为参数使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setTimeout(function()&#123;</span></span><br><span class="line"><span class="comment">//     console.log(1);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line">setTimeout(fn, <span class="number">1000</span>);  <span class="comment">// 传入函数体 而不是执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var newFn = fn();</span></span><br><span class="line"><span class="comment">// newFn();  // 1</span></span><br><span class="line">fn()();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><ol>
<li><p>字面量 定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">argument</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body...</span></span><br><span class="line">    <span class="comment">// add 是对外对内都可以使用的，fn只能在函数体内使用</span></span><br><span class="line">&#125;;</span><br><span class="line">add();</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须要用字符串</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>, <span class="string">'num2'</span>, <span class="string">'return num1+num2;'</span>);</span><br><span class="line">add();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="三种方式的区别"><a href="#三种方式的区别" class="headerlink" title="三种方式的区别"></a>三种方式的区别</h3><p>字面量方式更直观、更方便书写，更加省时，效率高。</p>
<p>函数声明、赋值语句：预解析的区别。</p>
<p>函数声明的方式，先定义或者先调用都可以。</p>
<p>赋值语句的方式，先定义可以，但是先调用的话就会报错，找不到函数。</p>
<p>是因为预解析的时候，解析器会先寻找开头关键字<code>var</code>、<code>function</code>，var在预解析的时候会默认赋值undefined，所以不是一个函数。</p>
<h3 id="三种方式的选择"><a href="#三种方式的选择" class="headerlink" title="三种方式的选择"></a>三种方式的选择</h3><p>构造函数的方式一般不会使用，主要是字面量的方式。</p>
<p>而字面量中的两种方式根据风格来。</p>
<h3 id="函数定义的位置-实战"><a href="#函数定义的位置-实战" class="headerlink" title="函数定义的位置 实战"></a>函数定义的位置 实战</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 在函数前、后、内、外 都可以找到这个函数</span></span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域， 遵循作用域链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 函数自己内部、父级内部 可以找到</span></span><br><span class="line">        <span class="comment">// body ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// body ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if、for 代码块， 最好不要在里面声明函数</span></span><br><span class="line"><span class="comment">// 需要注意的是，if、for代码块中属于全局作用域，所以两个函数都会声明</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的赋值</span></span><br><span class="line"><span class="comment">// 这样写的话，就可以实现  在特定的条件下声明函数</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> subtract = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象中的函数定义，也就是方法</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'xm'</span>,</span><br><span class="line">    setSex: <span class="function"><span class="keyword">function</span>(<span class="params">sex</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">person.setSex();</span><br></pre></td></tr></table></figure>

<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 这样是不能调用的，JS解析器的问题</span></span><br><span class="line">    <span class="comment">// 解析会认为这是一个声明，因为是function开头的，所以不能在声明的同时调用</span></span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">// 解决办法</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;(); <span class="comment">// 匿名函数的自我执行</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 避免了function打头，也就解决了问题</span></span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 还有在function之前加 !+-~都可以</span></span><br></pre></td></tr></table></figure>

<h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p><code>5! = 5 *4 * 3 * 2 * 1</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> operation = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">operation.add(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">operation.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'你点击了文档.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.onclick();  <span class="comment">// 模拟鼠标点击，适用于其他各种事件</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">对象里的属性，要不要加引号引起来？</span></span><br><span class="line"><span class="comment">对于合法的标识符，加不加引号都可以，都不会报错</span></span><br><span class="line"><span class="comment">但是对于一些不合法的标识符，就会报错，就用引号引起来。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).html(<span class="string">'段落'</span>).css(<span class="string">'background-color'</span>, <span class="string">'red'</span>)...;</span><br><span class="line"><span class="comment">// 自己写链式调用</span></span><br><span class="line"><span class="keyword">var</span> operation = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num1 - num2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">operation.add(<span class="number">1</span>, <span class="number">2</span>).subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的调用"><a href="#构造函数的调用" class="headerlink" title="构造函数的调用"></a>构造函数的调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="keyword">new</span> Person();  <span class="comment">// 返回的是一个对象，加上new调用才是构造函数，不加new调用就只是一个普通函数。</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<h3 id="函数的间接调用"><a href="#函数的间接调用" class="headerlink" title="函数的间接调用"></a>函数的间接调用</h3><p>每个函数下都会有 <code>call</code> 、<code>apply</code> 两个间接调用方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function add()&#123;</span></span><br><span class="line"><span class="comment">//     // body</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// add();</span></span><br><span class="line"><span class="comment">// add.call</span></span><br><span class="line"><span class="comment">// add.apply</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'xm'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">'xh'</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name;  <span class="comment">// 这里的this指向的是person</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName());</span><br><span class="line"><span class="comment">// call方法里的参数作用：改变this的位置，后面的参数才是传参</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName.call(<span class="built_in">window</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply第一个参数也是改变this指向</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add.call(<span class="built_in">window</span>, <span class="number">1</span>, <span class="number">2</span>));  <span class="comment">// call方法传参只需要按顺序传就好</span></span><br><span class="line"><span class="built_in">console</span>.log(add.apply(<span class="built_in">window</span>, [<span class="number">1</span>, <span class="number">2</span>]));  <span class="comment">// apply方法传参的时候要用数组</span></span><br><span class="line"><span class="comment">// 可以在继承中使用 call和apply，可以使用父类中的一些方法和属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 帮助判断数据结构 instanceof</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="参数的类型"><a href="#参数的类型" class="headerlink" title="参数的类型"></a>参数的类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;  <span class="comment">// 形参，只是一个占位符，当成var声明的局部变量，会预解析</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 实参</span></span><br><span class="line"><span class="comment">// 本质： 把实参赋值给形参，1-&gt;num1, 2-&gt;num2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是把对象（引用类型）当做参数传递的话， 赋值的是地址</span></span><br><span class="line">obj = person;  <span class="comment">// 指向同一个对象，所以在函数内做的对对象的操作，会影响外面的对象，也就是对形参的修改会影响实参</span></span><br></pre></td></tr></table></figure>

<h3 id="参数的个数"><a href="#参数的个数" class="headerlink" title="参数的个数"></a>参数的个数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>实参 == 形参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实参 &lt; 形参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1-&gt;num1 ,undefinded-&gt;num2</span></span><br></pre></td></tr></table></figure>

<p>可选参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">base, power</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(base, power);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写， 默认是2次幂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">base, power</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// if(!power) power = 2;</span></span><br><span class="line">    power = power || <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(base, power);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// jq里的，在什么上下文中选</span></span><br><span class="line">$(<span class="string">'p'</span>, <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>))  <span class="comment">// 缺省就选择默认的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实参 &gt; 形参  arguments</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 不限制参数的个数</span></span><br><span class="line"><span class="comment">// 改写函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用arguments类数组，里面保存的是所有的参数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>类数组，一个对象，没有数组独有的push等方法。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>arguments里面的每一个数据，和形参是一一对应的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="string">''</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);  <span class="comment">// ''</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'am'</span>);  <span class="comment">// ''</span></span><br><span class="line"><span class="comment">// 对于不可变类型string，name和arguments[0]指向的是同一个地址，修改一项会对另一项造成影响，所以尽量不要对arguments进行改操作，会影响形参</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments是每个函数中独有的。</p>
</li>
<li><p><code>arguments.callee</code> 这个属性是指函数本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);  <span class="comment">// 会打印出函数本体</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>  严格模式<code>use strict</code> 下，不适用var 声明的变量会报错，而且不能使用<code>arguments.callee</code></p>
</li>
</ol>
<h3 id="什么可以做参数"><a href="#什么可以做参数" class="headerlink" title="什么可以做参数"></a>什么可以做参数</h3><p>数字、字符串、布尔值、undefined（参数设计不合理时会使用）、null（同undefined）、数组、对象、函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传数组实例</span></span><br><span class="line">$.each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].length; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* -------------------------------------------------- */</span></span><br><span class="line"><span class="comment">// 传入对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">name, sex</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">    person.name = name;</span><br><span class="line">    person.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">setPerson(<span class="string">'xm'</span>, <span class="string">'male'</span>);</span><br><span class="line"><span class="comment">// 需求变了，需要添加不定长参数给到person</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPerson</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">    person.name = obj.name || <span class="string">'xh'</span>;</span><br><span class="line">    person.sex = obj.sex || <span class="string">'male'</span>;</span><br><span class="line">    person.age = obj.age || <span class="string">'18'</span>;</span><br><span class="line">    person.tel = obj.tel || <span class="string">'110'</span>;</span><br><span class="line">    person.addr = obj.addr || <span class="string">'China'</span>;</span><br><span class="line">&#125;</span><br><span class="line">setPerson(&#123;</span><br><span class="line">	name: <span class="string">'xm'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    addr: <span class="string">'China'</span>,</span><br><span class="line">    sex: <span class="string">'male'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>在函数中使用</p>
<p>函数的输出</p>
<p>表示函数的结束，并将值返回。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环中使用</p>
<p>表示跳出本次循环，并不是跳出所有循环</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在循环中使用</p>
<p>表示跳出所有循环</p>
<h3 id="什么可以作为返回值"><a href="#什么可以作为返回值" class="headerlink" title="什么可以作为返回值"></a>什么可以作为返回值</h3><p>和参数差不多，只要是数据就都可以返回。</p>
<h1 id="实现简易计算器"><a href="#实现简易计算器" class="headerlink" title="实现简易计算器"></a>实现简易计算器</h1><h2 id="结构和样式"><a href="#结构和样式" class="headerlink" title="结构和样式"></a>结构和样式</h2><p>结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简易计算器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"calculator"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"formerInput"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sign"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"laterInput"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span>&gt;</span>=<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"resultOutput"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"+"</span> <span class="attr">onclick</span>=<span class="string">"addHandler();"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"-"</span> <span class="attr">onclick</span>=<span class="string">"subtractHandler();"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"*"</span> <span class="attr">onclick</span>=<span class="string">"multiplyHandler();"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"/"</span> <span class="attr">onclick</span>=<span class="string">"divideHandler();"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#calculator</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加JS"><a href="#添加JS" class="headerlink" title="添加JS"></a>添加JS</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">var</span> calculator = <span class="built_in">document</span>.querySelector(<span class="string">'#calculator'</span>);</span><br><span class="line"><span class="keyword">var</span> formerInput = calculator.querySelector(<span class="string">'.formerInput'</span>);</span><br><span class="line"><span class="keyword">var</span> laterInput = calculator.querySelector(<span class="string">'.laterInput'</span>);</span><br><span class="line"><span class="keyword">var</span> sign = calculator.querySelector(<span class="string">'.sign'</span>);</span><br><span class="line"><span class="keyword">var</span> resultOutput = calculator.querySelector(<span class="string">'.resultOutput'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	sign.innerHTML = <span class="string">"+"</span>;</span><br><span class="line">	resultOutput.innerHTML = +formerInput.value + +laterInput.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtractHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	sign.innerHTML = <span class="string">"+"</span>;</span><br><span class="line">	resultOutput.innerHTML = formerInput.value - laterInput.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	sign.innerHTML = <span class="string">"+"</span>;</span><br><span class="line">	resultOutput.innerHTML = formerInput.value * laterInput.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divideHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	sign.innerHTML = <span class="string">"+"</span>;</span><br><span class="line">	resultOutput.innerHTML = formerInput.value / laterInput.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进一-结构和行为分离"><a href="#改进一-结构和行为分离" class="headerlink" title="改进一 结构和行为分离"></a>改进一 结构和行为分离</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次改进，将结构和行为分离</span></span><br><span class="line"><span class="keyword">var</span> btns = calculator.querySelectorAll(<span class="string">'.btn'</span>);</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="comment">// +</span></span><br><span class="line">btns[<span class="number">0</span>].onclick = addHandler;</span><br><span class="line">btns[<span class="number">1</span>].onclick = subtractHandler;</span><br><span class="line">btns[<span class="number">2</span>].onclick = multiplyHandler;</span><br><span class="line">btns[<span class="number">3</span>].onclick = divideHandler;</span><br></pre></td></tr></table></figure>

<h2 id="改进二-使用循环"><a href="#改进二-使用循环" class="headerlink" title="改进二 使用循环"></a>改进二 使用循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二次改进，使用循环添加事件</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; btns.length; i++)&#123;</span><br><span class="line">	btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="keyword">this</span>.title)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">			addHandler();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'subtract'</span>:</span><br><span class="line">			subtractHandler();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'multiply'</span>:</span><br><span class="line">			multiplyHandler();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'divide'</span>:</span><br><span class="line">			divideHandler();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进三-封装函数"><a href="#改进三-封装函数" class="headerlink" title="改进三 封装函数"></a>改进三 封装函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三次改进 封装函数</span></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">each(btns, <span class="function"><span class="keyword">function</span>(<span class="params">index, elem</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">    elem.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.title) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                addHandler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'subtract'</span>:</span><br><span class="line">                subtractHandler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'multiply'</span>:</span><br><span class="line">                multiplyHandler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'divide'</span>:</span><br><span class="line">                divideHandler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">array, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        fn(i, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新符号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateSign</span>(<span class="params">symbol</span>)</span>&#123;</span><br><span class="line">	sign.innerHTML = symbol</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> +num1 + +num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSign(<span class="string">'+'</span>);</span><br><span class="line">    resultOutput.innerHTML = add(formerInput.value, laterInput.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> +num1 - +num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtractHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSign(<span class="string">'-'</span>);</span><br><span class="line">    resultOutput.innerHTML = subtract(formerInput.value, laterInput.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> +num1 * +num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSign(<span class="string">'*'</span>);</span><br><span class="line">    resultOutput.innerHTML = multiply(formerInput.value, laterInput.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> +num1 / +num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divideHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    updateSign(<span class="string">'/'</span>);</span><br><span class="line">    resultOutput.innerHTML = divide(formerInput.value, laterInput.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进四-管理代码"><a href="#改进四-管理代码" class="headerlink" title="改进四 管理代码"></a>改进四 管理代码</h2><p>把calculator下的零散的变量通过一个对象来存取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第四次修改，管理代码</span></span><br><span class="line"><span class="keyword">var</span> wrapElem = <span class="built_in">document</span>.querySelector(<span class="string">'#calculator'</span>);</span><br><span class="line"><span class="keyword">var</span> calculatorElem = &#123;</span><br><span class="line">	formerInput: wrapElem.querySelector(<span class="string">'.formerInput'</span>),</span><br><span class="line">	laterInput: wrapElem.querySelector(<span class="string">'.laterInput'</span>),</span><br><span class="line">	sign: wrapElem.querySelector(<span class="string">'.sign'</span>),</span><br><span class="line">	resultOutput: wrapElem.querySelector(<span class="string">'.resultOutput'</span>),</span><br><span class="line">	btns: wrapElem.querySelectorAll(<span class="string">'.btn'</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把小函数分组织</span></span><br><span class="line"><span class="keyword">var</span> operation = &#123;</span><br><span class="line">    <span class="comment">// 加</span></span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +num1 + +num2</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +num1 - +num2</span><br><span class="line">    &#125;,</span><br><span class="line">    multiply: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +num1 * +num2</span><br><span class="line">    &#125;,</span><br><span class="line">    divide: <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +num1 / +num2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后把使用到的地方的变量修改即可</span></span><br><span class="line"><span class="comment">// 然后把使用到的地方的变量修改即可</span></span><br></pre></td></tr></table></figure>



<h1 id="面向对象-OOP"><a href="#面向对象-OOP" class="headerlink" title="面向对象  OOP"></a>面向对象  OOP</h1><p>一切事物皆对象。</p>
<p>对代码的一种抽象，对外统一提供调用接口的编程思想。</p>
<h2 id="基于原型的面向对象"><a href="#基于原型的面向对象" class="headerlink" title="基于原型的面向对象"></a>基于原型的面向对象</h2><p>基于原型的面向对象方式中，对象（Object）则是依靠构造器（constructor）利用原型（prototype）构造出来的。</p>
<ul>
<li><p>属性：事物的特征</p>
<p>事物自身拥有的东西，比如人有名字、身高、体重等。</p>
</li>
<li><p>方法：事物的功能</p>
<p>比如人可以学习、唱歌、玩耍。</p>
</li>
<li><p>对象：事物的一个实例</p>
<p>比如是众多人中的一个人。</p>
</li>
<li><p>原型：Js函数中由prototype属性引用了一个对象，即原型对象（原型）。</p>
<p>prototype在内存中是指向一个地址的，这个地址中存储了一个对象，Object是Js的父对象。</p>
</li>
</ul>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>函数构造器 创造函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Function</span>(var1, var2, ..., functionBody());</span><br><span class="line"><span class="comment">// var1, var2 正常变量 functionBody() 自定义函数体，可以用到前面的变量</span></span><br><span class="line"><span class="comment">// 注意：构造器构造的对象，效率低</span></span><br><span class="line"><span class="comment">// var1、var2顺序在functionBody中不能变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>);</span><br><span class="line"><span class="keyword">var</span> s = obj(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">alert(s);  <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 说明： 对象分为函数对象、普通对象，通过new Function 创建的对象都是函数对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h2><p>闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(++i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a();</span><br><span class="line">c();</span><br><span class="line"><span class="comment">// 特点：函数b是在函数a内嵌套的，函数a需要返回函数b</span></span><br></pre></td></tr></table></figure>

<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol>
<li><p>读取函数内部变量</p>
</li>
<li><p>让i 变量的值，保留在内存中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">    nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rs = f1();</span><br><span class="line">rs();  <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">rs();  <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">/// 说明：f2依赖f1，rs一旦声明，f1里的局部变量n就会一直保存在内存中，知道变量被回收。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点： 有利于封装可以访问局部变量</li>
<li>缺点：内存占用事件比较长，浪费严重，容易造成内存泄漏，谨慎使用。</li>
</ul>
<h2 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h2><h3 id="字面式对象声明"><a href="#字面式对象声明" class="headerlink" title="字面式对象声明"></a>字面式对象声明</h3><p>Js中最基础的方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    属性名称： 属性值,</span><br><span class="line">    ...</span><br><span class="line">    方法名称: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zhangsan"</span>,</span><br><span class="line">    age: <span class="number">26</span>,</span><br><span class="line">    sex: <span class="string">"man"</span>,</span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span>(<span class="params">fds</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"在吃"</span>+fds);</span><br><span class="line">    &#125;,</span><br><span class="line">    play: <span class="function"><span class="keyword">function</span>(<span class="params">ga</span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"我在玩"</span>+ga);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.eat(<span class="string">"面条"</span>);  <span class="comment">// person也是Object的一个子对象</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="new操作符后跟Object构造函数"><a href="#new操作符后跟Object构造函数" class="headerlink" title="new操作符后跟Object构造函数"></a>new操作符后跟Object构造函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 对象是所有对象的基类</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.属性 = 属性值;</span><br><span class="line">...</span><br><span class="line">obj.方法 = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>)</span>&#123;</span><br><span class="line">    方法代码;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">box.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">box.age = <span class="number">100</span>;</span><br><span class="line">box.infos = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">'--'</span>+<span class="keyword">this</span>.age+<span class="string">'---'</span>+str;  <span class="comment">// this 为当前对象</span></span><br><span class="line">&#125;  <span class="comment">// 用的时候就可以直接使用box</span></span><br><span class="line">box.name;</span><br><span class="line">box.infos(<span class="string">"吃饭"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JS中构造方法声明对象"><a href="#JS中构造方法声明对象" class="headerlink" title="JS中构造方法声明对象"></a>JS中构造方法声明对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">[参数列表]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.属性 = 属性值;</span><br><span class="line">    <span class="keyword">this</span>.方法 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        方法代码；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> test(参数列表);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, sex, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"我是show方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> person(<span class="string">"张三"</span>, <span class="string">"man"</span>, <span class="number">18</span>);</span><br><span class="line">obj1.name;</span><br><span class="line">obj1.age;</span><br><span class="line"><span class="comment">// 注意：this代表当前对象，obj1和obj2两者之间是独立的，函数内部只能用this访问属性和方法</span></span><br></pre></td></tr></table></figure>

<h3 id="工厂方式声明对象"><a href="#工厂方式声明对象" class="headerlink" title="工厂方式声明对象"></a>工厂方式声明对象</h3><p>在一个方法中声明一个object对象，并赋予这个对象一些属性和方法，最后返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 在obj对象中 调用obj对象的属性，使用this</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">'--'</span> + <span class="keyword">this</span>.age + <span class="string">'运行中...'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'say方法'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> box1 = createObject(<span class="string">"张三"</span>, <span class="number">18</span>);</span><br><span class="line">box1.name;  <span class="comment">// 张三</span></span><br><span class="line">box1.age;  <span class="comment">// 18</span></span><br><span class="line">box1.run();  <span class="comment">// 张三--18运行中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> box2 = createObject(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line">box2.say();  <span class="comment">// say方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// box1和box2两个对象是没有关系的，是独立存在的。</span></span><br></pre></td></tr></table></figure>

<h3 id="js中原型模式声明对象"><a href="#js中原型模式声明对象" class="headerlink" title="js中原型模式声明对象"></a>js中原型模式声明对象</h3><p>任何js方法，都有一个prototype属性，且它以对象方式存在。</p>
<p><strong>原型模式根本：</strong> 函数本身声明为空内容，利用prototype定义一些属性和方法。    </p>
<p>好处：可以让所有的实例共享它包含的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">test.prototype();  <span class="comment">// 一个Object对象，自带的。</span></span><br><span class="line">test.prototype.color = <span class="string">"red"</span>;</span><br><span class="line">test.prototype.heights = <span class="string">"1.7"</span>;</span><br><span class="line">test.prototype.widths = <span class="string">"1.2"</span>;</span><br><span class="line">test.prototype.showInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color+<span class="keyword">this</span>.heights+widths;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> test();</span><br><span class="line">car1.color;  <span class="comment">// red</span></span><br><span class="line">..</span><br><span class="line">car1.showInfo();  <span class="comment">// 调用成功</span></span><br><span class="line"><span class="comment">// json数据的方式定义属性和方法，和上面一样的效果</span></span><br><span class="line">test.prototype = &#123;</span><br><span class="line">    color: <span class="string">"red"</span>;</span><br><span class="line">    heights: <span class="string">"1.7"</span>;</span><br><span class="line">    widths: <span class="string">"1.2"</span>; </span><br><span class="line">    showInfo：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	alert(<span class="keyword">this</span>.color+<span class="keyword">this</span>.heights+widths;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>也就是构造+原型 的模式</p>
<p><img src="/2019/01/20/JavaScript%E6%B7%B1%E5%85%A5/image-20191215173831679.png" alt="image-20191215173831679"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混合模式： 构造+原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blog</span>(<span class="params">name, url, friend</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = namel</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.friends = friends;</span><br><span class="line">&#125;</span><br><span class="line">blog.prototype = &#123;</span><br><span class="line">	showInfo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    	alert(<span class="keyword">this</span>.name+<span class="keyword">this</span>.url+<span class="keyword">this</span>.frients);</span><br><span class="line">	&#125;,</span><br><span class="line">    gets: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.friends);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><p>对象可以当做数组处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ren = &#123;&#125;;</span><br><span class="line">        ren.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">        ren.age = <span class="number">18</span>;</span><br><span class="line">        ren.demo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="built_in">document</span>.write(<span class="string">"aaa"</span>);</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ren)&#123;  <span class="comment">// i 是所有的属性或者方法名称</span></span><br><span class="line">    alert(ren[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的存储"><a href="#对象的存储" class="headerlink" title="对象的存储"></a>对象的存储</h2><p>对象在内存中的分布</p>
<p>一般会把内存分为： 堆内存、栈内存、代码段、数据段。</p>
<p>对象就是一个引用，引用到了一个地址，16进制的数字，这个地址上面描述了内存中的属性和方法，属性和方法在堆内存中存储着，function、alert等是放在代码段中，两个对象之间是互相独立的。</p>
<h2 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h2><p>把对象内部数据和操作细节进行隐藏</p>
<p>大多面向对象的语言都支持封装的特性，提供了private关键字来隐藏某些属性或方法，用来限制被封装的数据或者内容的让问，只对外提供一个独享的专门访问的接口。也就是调用方法。</p>
<p>但是在JS中没有提供关键字，只通过闭包来实现封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;  <span class="comment">// 局部变量，在方法外部不能直接访问</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// 出口，特权方法</span></span><br><span class="line">        <span class="keyword">return</span> n++;</span><br><span class="line">     &#125;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">alert(demo());</span><br></pre></td></tr></table></figure>

<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p>原型：是利用prototype添加属性和方法。</p>
<p>原型链：JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，用于指向创建它的函数对象的原型对象的prototype。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js 继承</span></span><br><span class="line"><span class="comment">// 原型：用prototype对象来添加属性和方法</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> person();  <span class="comment">// 经历了下面三个阶段</span></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;;   <span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">p.__proto__ = person.prototype;  <span class="comment">// __proto__自带的一个属性</span></span><br><span class="line"><span class="comment">// 3 创建对象（初始化对象）p --&gt; person.call(p)</span></span><br><span class="line">alert(p.__proto__ == person.prototype);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span> &#125;;</span><br><span class="line">person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">"天气挺好"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">person.prototype.gongzi = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">var</span> programmer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(programmer.prototype);  <span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line">programmer.prototype = <span class="keyword">new</span> person();  <span class="comment">// 注意这！把programmer的原型指向了person;</span></span><br><span class="line"><span class="built_in">console</span>.log(programmer.prototype);  <span class="comment">// person &#123;name: "zhangsan"&#125;</span></span><br><span class="line"></span><br><span class="line">programmer.prototype.wcd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    alert(<span class="string">"明天天气也不错"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">programmer.prototype.gongzi = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> programmer()</span><br><span class="line">p.say();  <span class="comment">// 成功调用</span></span><br><span class="line">p.wcd();  <span class="comment">// 成功调用</span></span><br></pre></td></tr></table></figure>

<h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><p>在子类内部构造父类的对象实现继承</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parents</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"父亲名："</span>+<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params">name, age</span>)</span>&#123;  <span class="comment">// 继承parents</span></span><br><span class="line">    <span class="keyword">this</span>.pObj = parents;  <span class="comment">// 子对象的参数name就传到了父对象中了</span></span><br><span class="line">    <span class="keyword">this</span>.pObj(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayC = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"子名字："</span>+<span class="keyword">this</span>.name+<span class="string">"age:"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = parents(<span class="string">"zhangsan"</span>);</span><br><span class="line">p.say();  <span class="comment">// 成功调用</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> child(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line">c.sayC();  <span class="comment">// 成功调用</span></span><br></pre></td></tr></table></figure>



<h2 id="js-面向对象的关键词"><a href="#js-面向对象的关键词" class="headerlink" title="js 面向对象的关键词"></a>js 面向对象的关键词</h2><ul>
<li><p>instanceof</p>
<p>变量是否是对象的实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// true</span></span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>delete</p>
<p>删除对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fun();</span><br><span class="line">alert(obj.name);  <span class="comment">// zhangsan</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;  <span class="comment">// 作为运算符存在了，而不是方法</span></span><br><span class="line">alert(obj.name);  <span class="comment">// undefinded</span></span><br><span class="line"><span class="comment">// delete不能删除方法，也不能删除变量，而且不能删除原型链中的属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>call、apply</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"ani"</span>;</span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"cat"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> an = <span class="keyword">new</span> animal();</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> cat();</span><br><span class="line"><span class="comment">// an.showName.call(c, ",");  // 通过call方法，将showName --&gt; cat使用了</span></span><br><span class="line">an.showName.apply(c, []);  <span class="comment">// 同call方法一样</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>callee</p>
<p>返回正在执行的function对象，function内容</p>
<p>callee是arguments的一个属性，默认值是正在执行的function对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>.callee);  <span class="comment">// callee当作属性，返回整个函数的内容</span></span><br><span class="line">    alert(<span class="built_in">arguments</span>.callee());  <span class="comment">// 报错，死循环，最大栈被占用</span></span><br><span class="line">&#125;</span><br><span class="line">demo();</span><br><span class="line"><span class="comment">// 可以写递归</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>arguments </p>
<p>每个函数都有一个Arguments对象的实例arguments，引用函数的参数（实参）</p>
<p>可以用数组下标方式引用arguments元素</p>
<p><code>arguments.length</code>，参数个数</p>
<p><code>arguments.callee</code>，引用函数自身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>.length);  <span class="comment">// 3</span></span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>this <strong>重要</strong></p>
<ol>
<li><p>this作为函数调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;  <span class="comment">// 这里的this就是全局变量global， 相当于 x=1</span></span><br><span class="line">    alert(<span class="keyword">this</span>.x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为方法调用  –&gt;  构造函数内this指向当前对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"zhangsan"</span>;  <span class="comment">// this表示当前对象</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> test();</span><br><span class="line">alert(t.name);  <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在call、apply中使用，this第一个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.x = <span class="number">1</span>;</span><br><span class="line">o.m = test;</span><br><span class="line">o.m.allpy();  <span class="comment">// 0</span></span><br><span class="line">o.m.apply(o);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h2><p>将父类的属性和方法一起传给子类作为特权属性和特权方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象冒充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.prototype.walk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"walk"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">students</span>(<span class="params">name, age, grade</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.newMethod = person;</span><br><span class="line">    <span class="keyword">this</span>.newMethod(name, age);  <span class="comment">// 可以冒充是person对象，传递特权属性和特权方法给子类了</span></span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> student(<span class="string">"zhangsan"</span>, <span class="number">15</span>, <span class="number">5</span>);  <span class="comment">// s1 是students独享，继承person</span></span><br><span class="line"><span class="comment">// 注意，s1继承了person中的特权方法和属性，但是没有继承共有方法和属性</span></span><br></pre></td></tr></table></figure>

<h1 id="正则表达式-regular-expression"><a href="#正则表达式-regular-expression" class="headerlink" title="正则表达式 regular expression"></a>正则表达式 regular expression</h1><p>正则表达式是由普通字符（例如26个英文字母、数字等）以及特殊字符（有特殊含义的，例如 <code>.</code> <code>\</code>等）组成的文字模式。</p>
<p>该模式描述在查找文字主题时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<p>正则可以用来做查找、替换、数据有效性验证。</p>
<h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><ol>
<li><p>字面量或直接量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/js/</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>初识正则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"I love js"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/js/</span>;</span><br><span class="line"><span class="comment">// 两种正则方法 test exec</span></span><br><span class="line">pattern.test(str);  <span class="comment">// 找到就返回true，找不到就返回false</span></span><br><span class="line">pattern.exec(str);  <span class="comment">// 找到就把找到的字符串组成数组，然后返回。 // ["js"]，找不到返回null</span></span><br><span class="line"><span class="comment">// 修饰符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i	:	ignoreCase	忽略大小写</span></span><br><span class="line"><span class="comment">g	：	global		全局匹配</span></span><br><span class="line"><span class="comment">m	：	multiline	多行匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/js/i</span>;  <span class="comment">// 修饰符可以连用，直接在i后面或前面加上就可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数写法</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"I love js"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"js"</span>, <span class="string">"i"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern.test(str));</span><br><span class="line"><span class="built_in">console</span>.log(pattern.exec(str));</span><br></pre></td></tr></table></figure>

<p>使用构造函数的写法，是把正则规则以字符串的模式传递的，所以可以改变，更灵活。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'// 我是注释'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\/\//</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'\\'</span>;  <span class="comment">// 一条反斜杠</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\\/</span>;  <span class="comment">// 一条反斜杠</span></span><br><span class="line"></span><br><span class="line">\	转义符</span><br><span class="line">\n	换行符</span><br><span class="line">\t	制表符</span><br><span class="line"></span><br><span class="line"><span class="comment">// \u4e00 ~ \u9fa5</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"Alex帅"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/[\u4e00-\u9fa5]/</span>;  <span class="comment">// 匹配汉字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'javascript'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/[js]/</span>;</span><br></pre></td></tr></table></figure>

<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul>
<li><p><code>[]</code>中括号</p>
<p>表示匹配中括号中的任意一个字符，先匹配到谁就是谁</p>
<p><code>[a-z]</code>  a到z之间的任意字符 <code>[a-zA-Z]</code> <code>[a-zA-Z0-9]</code></p>
</li>
<li><p><code>^</code> 取反</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'javascript'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/[^js]/</span>;  <span class="comment">// 表示匹配除了js之外的所有字符</span></span><br><span class="line">pattern.exec(str);  <span class="comment">// a</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>.</code> 除了换行符之外的所有字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'3.1415926'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/./</span>;</span><br><span class="line">pattern.exec(str);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>\w</code>  表示 <code>[a-zA-Z0-9_]</code></p>
</li>
<li><p><code>\W</code> 表示小写w的取反 <code>[^a-zA-Z0-9_]</code></p>
</li>
<li><p><code>\d</code> 表示<code>[0-9]</code></p>
</li>
<li><p><code>\D</code> 表示 <code>[^0-9]</code></p>
</li>
<li><p><code>\s</code> 表示 空格和制表符，以及Unicode中的其他空白字符</p>
</li>
<li><p><code>\S</code> 小s取反</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端 - JS</category>
      </categories>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/2019/04/20/Vue%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/lifecycle.png" alt></p><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304130707269.png" alt="image-20200304130707269"></p><h1 id="选项数据-data"><a href="#选项数据-data" class="headerlink" title="选项数据 data"></a>选项数据 data</h1><ul>
<li>data</li>
<li>computed</li>
<li>methods</li>
</ul><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304135159167.png" alt="image-20200304135159167"></p><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304134142966.png" alt="image-20200304134142966"></p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><ul>
<li>data</li>
<li>模板中直接嵌入js代码</li>
<li>指令 v-html、v-on、v-bind等</li>
<li>计算属性</li>
<li>过滤器</li>
</ul><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304151528360.png" alt="image-20200304151528360"></p><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304151547044.png" alt="image-20200304151547044"></p><h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h1><a id="more"></a>







<ul>
<li>在模板中放入太多的逻辑会让模板过重且难以维护</li>
<li>计算属性下所有函数可以放到computed中</li>
</ul>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304153020080.png" alt="image-20200304153020080"></p>
<h1 id="Class与Style动态绑定-v-bind"><a href="#Class与Style动态绑定-v-bind" class="headerlink" title="Class与Style动态绑定  v-bind"></a>Class与Style动态绑定  v-bind</h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304153339478.png" alt="image-20200304153339478"></p>
<h2 id="class-绑定方式"><a href="#class-绑定方式" class="headerlink" title="class 绑定方式"></a>class 绑定方式</h2><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304153423576.png" alt="image-20200304153423576"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304160807281.png" alt="image-20200304160807281"></p>
<h2 id="style-绑定方式"><a href="#style-绑定方式" class="headerlink" title="style 绑定方式"></a>style 绑定方式</h2><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304153436175.png" alt="image-20200304153436175"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304161638753.png" alt="image-20200304161638753"></p>
<h1 id="条件渲染-v-if-v-else-v-else-if"><a href="#条件渲染-v-if-v-else-v-else-if" class="headerlink" title="条件渲染 v-if v-else v-else-if"></a>条件渲染 v-if v-else v-else-if</h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304163221254.png" alt="image-20200304163221254"></p>
<h1 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染 v-for"></a>列表渲染 v-for</h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304163239885.png" alt="image-20200304163239885"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304165902445.png" alt="image-20200304165902445"></p>
<h1 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304212141937.png" alt="image-20200304212141937"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304214749319.png" alt="image-20200304214749319"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304214800556.png" alt="image-20200304214800556"></p>
<h1 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304214905161.png" alt="image-20200304214905161"></p>
<p> 之前的Demo都是下载src/pages/ 目录下， pages目录下可以理解为一个个的 页面</p>
<p>compontents 组件，是放在 页面内的。</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304220748690.png" alt="image-20200304220748690"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200304220757595.png" alt="image-20200304220757595"></p>
<h2 id="父子组件之间通信！"><a href="#父子组件之间通信！" class="headerlink" title="父子组件之间通信！"></a><a href="https://segmentfault.com/a/1190000014381699" target="_blank" rel="noopener">父子组件之间通信！</a></h2><h2 id="VUE中的DOM操作-this-refs"><a href="#VUE中的DOM操作-this-refs" class="headerlink" title="VUE中的DOM操作  this.$refs"></a>VUE中的DOM操作  this.$refs</h2><p>不建议使用VUE的时候直接操作DOM</p>
<p>非要操作的时候要在 <strong>mounted</strong> 生命周期函数里面使用，因为vue使用了虚拟DOM，挂载后也就变成了真实DOM</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305134935840.png" alt="image-20200305134935840"></p>
<h1 id="过渡效果-transition"><a href="#过渡效果-transition" class="headerlink" title="过渡效果 transition"></a>过渡效果 transition</h1><p>通过样式的方式写过渡</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305141825815.png" alt="image-20200305141825815"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305141843782.png" alt="image-20200305141843782"></p>
<h1 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 vue-router"></a><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">路由 vue-router</a></h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305142222566.png" alt="image-20200305142222566"></p>
<p>之前做的Demo每个页面都是单独的，在<code>router/index.js</code> 里面添加路由</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305142031513.png" alt="image-20200305142031513"></p>
<p>解决页面之间的跳转</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305152119476.png" alt="image-20200305152119476"></p>
<p>被跳转的页面 获取 params以及query： </p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305152155219.png" alt="image-20200305152155219"></p>
<h1 id="！状态管理-vuex"><a href="#！状态管理-vuex" class="headerlink" title="！状态管理 vuex"></a>！状态管理 <a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex</a></h1><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305152325866.png" alt="image-20200305152325866"></p>
<p>看图理解</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305152519852.png" alt="image-20200305152519852"></p>
<p>这种多页面跳转的话，通过路由传值就会变得特别麻烦</p>
<p>这时候只要有一个共享数据池，也就是全局状态管理，那么就不需要传了，直接去vuex里面取就可以了。</p>
<h2 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h2><p>vuex的store目录在 /src/目录下</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305154930049.png" alt="image-20200305154930049"></p>
<p>在Vue实例中使用</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305155004080.png" alt="image-20200305155004080"></p>
<p>基本使用（获取、修改）</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305155032129.png" alt="image-20200305155032129"></p>
<h1 id="Slot-插槽"><a href="#Slot-插槽" class="headerlink" title="Slot 插槽"></a>Slot 插槽</h1><p>常用于组件调用中</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305225932442.png" alt="image-20200305225932442"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305225945009.png" alt="image-20200305225945009"></p>
<h1 id="vue-resource请求"><a href="#vue-resource请求" class="headerlink" title="vue-resource请求"></a>vue-resource请求</h1><p>类似ajax请求，给后台发送请求接口</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305230044255.png" alt="image-20200305230044255"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200305231034292.png" alt="image-20200305231034292"></p>
<h1 id="移动组件库-Mint-UI"><a href="#移动组件库-Mint-UI" class="headerlink" title="移动组件库 Mint UI"></a>移动组件库 <a href="http://mint-ui.github.io/docs/#/zh-cn" target="_blank" rel="noopener">Mint UI</a></h1><p>前言：</p>
<p>VUE最主要的就是在做组件开发，最终还是要回归组件开发，大部分时间都是在做组件开发，每个页面只是调用开发的组件。上述就是别人写好的组件，打包好了，我们可以直接用。</p>
<h1 id="练手小项目"><a href="#练手小项目" class="headerlink" title="练手小项目"></a>练手小项目</h1><p>使用vue脚手架搭建</p>
<p>为了做移动端适配，使用 rem 布局， 新建 <code>/src/config/rem.js</code> 在<code>main.js</code> 下做配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eslint-disable no-undef */</span></span><br><span class="line"><span class="comment">// 第一行做eslint忽略</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span>  e=n.document,</span><br><span class="line">       t=e.documentElement,</span><br><span class="line">       i=<span class="number">720</span>,</span><br><span class="line">       d=i/<span class="number">100</span>,</span><br><span class="line">       o=<span class="string">"orientationchange"</span><span class="keyword">in</span> n?<span class="string">"orientationchange"</span>:<span class="string">"resize"</span>,</span><br><span class="line">       a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> n=t.clientWidth||<span class="number">320</span>;n&gt;<span class="number">720</span>&amp;&amp;(n=<span class="number">720</span>);</span><br><span class="line">           t.style.fontSize=n/d+<span class="string">"px"</span></span><br><span class="line">       &#125;;</span><br><span class="line">       e.addEventListener&amp;&amp;(n.addEventListener(o,a,!<span class="number">1</span>),e.addEventListener(<span class="string">"DOMContentLoaded"</span>,a,!<span class="number">1</span>))</span><br><span class="line">&#125;(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>然后在 <code>main.js</code> 中引入一下 <code>import &#39;@/config/rem&#39;</code>  就可以使用了</p>
<p><strong>注意： 此章节配置都是基于vue-cli2 版本，cli3需另外研究</strong></p>
<p>px自动转换rem、可配置转换</p>
<ol>
<li><p>下载loader <code>npm i px2rem-loader</code></p>
</li>
<li><p>在 <code>/build/utils.js 中配置</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200306153118229.png" alt="image-20200306153118229"></p>
</li>
<li><p>使用，选择性转换</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200306153149557.png" alt="image-20200306153149557"></p>
<p>在项目中任意地方使用，默认会将<code>px</code> 转换为<code>rem</code> ，后面加注释 <code>/* no */</code> 则为不转换</p>
</li>
</ol>
<h2 id="实现head-部分"><a href="#实现head-部分" class="headerlink" title="实现head 部分"></a>实现head 部分</h2><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200306153837455.png" alt="image-20200306153837455"></p>
<p><strong>header是很多页面都会共享使用的，所以把它做成一个公共组件，可复用。</strong></p>
<h1 id="项目2-商城"><a href="#项目2-商城" class="headerlink" title="项目2 商城"></a>项目2 商城</h1><h2 id="创建目录结构"><a href="#创建目录结构" class="headerlink" title="创建目录结构"></a>创建目录结构</h2><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307014221367.png" alt="image-20200307014221367"></p>
<h2 id="静态文件准备"><a href="#静态文件准备" class="headerlink" title="静态文件准备"></a>静态文件准备</h2><p>准备一些图片，主要学习scss的架构</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307020824614.png" alt="image-20200307020824614"></p>
<h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>把脚手架初始化的东西删掉，然后再加自己的东西</p>
<p>安装</p>
<p><code>babel-polyfill</code> ：添加ES6的API使用</p>
<p><code>fastclick</code>：解决移动端300毫秒点击</p>
<p>在<code>main.js</code>入口文件下配置</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307021117926.png" alt="image-20200307021117926"></p>
<p>安装sass依赖 <code>node-sass</code>  <code>sass-loader</code></p>
<p><code>utils.js</code> 中已经预配置好了，不需要自己配置</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307021449670.png" alt="image-20200307021449670"></p>
<p><code>@</code> 代表 <code>/src</code> 路径，其实是在 <code>build/webpack.base.conf.js</code> 中配置的</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307021645261.png" alt="image-20200307021645261"></p>
<p>可以自己再配置一些常用路径，如下</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307021818102.png" alt="image-20200307021818102"></p>
<h2 id="搭建项目骨架、分析"><a href="#搭建项目骨架、分析" class="headerlink" title="搭建项目骨架、分析"></a>搭建项目骨架、分析</h2><p>将 <code>&lt;html&gt;</code> 、 <code>&lt;body&gt;</code> 、 <code>app</code> 设置超出隐藏、宽高设置成100%</p>
<p>这时候就设置好了一个可视区，并且上面三个元素是无法滚动的，浏览器默认的滚动条被禁用</p>
<p>只需要再在里面设置子元素可滚动</p>
<p>在父组件、页面级父组件中，只做标签的占位，不会写具体代码，具体代码就放到子组件中写，易于复用。也就是说子组件不包含位置信息，位置信息交给父组件。</p>
<p><code>App.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307134828082.png" alt="image-20200307134828082"></p>
<p>新建 <code>_comtainers.scss</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307134925511.png" alt="image-20200307134925511"></p>
<p>在 <code>_base.scss</code> 中设置html、body宽高为 100%</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307135012618.png" alt="image-20200307135012618"></p>
<h2 id="底部tabbar导航条组件"><a href="#底部tabbar导航条组件" class="headerlink" title="底部tabbar导航条组件"></a>底部tabbar导航条组件</h2><p>组件创建到 <code>components/</code> 目录下，病床简称目录的形式，因为可能会包含一些资源文件，就近引入。</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307135333159.png" alt="image-20200307135333159"></p>
<p>最后集成scss，创建 <code>_tabbar.scss</code>，将sass部分copy过去</p>
<p><strong>注意：</strong> 因为项目使用flex布局，关于flex布局会经常用到，就要提取出一个mixin函数，就可以复用了。</p>
<p>在 <code>_mixins.scss</code> 中定义</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307135641162.png" alt="image-20200307135641162"></p>
<p>定义居中，参数接收水平还是垂直排列，flex布局默认为row行排列</p>
<p>效果：</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307135905122.png" alt="image-20200307135905122"></p>
<p>变为</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307135931538.png" alt="image-20200307135931538"></p>
<p>最后，router-link 在被激活的时候会被加上 class<code>router-link-active</code>，</p>
<p>我们定义被激活后的样式，在 <code>tabbar/index.vue</code>中，这段css代码不需要集成</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307140603393.png" alt="image-20200307140603393"></p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>先把页面pages建好</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307143138674.png" alt="image-20200307143138674"></p>
<p>在 <code>router/index.js/</code> 里配置路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// import Home from 'pages/home'  // 路由懒加载后就不在这引入了 ！！</span></span><br><span class="line"><span class="comment">// import Cart from 'pages/cart'</span></span><br><span class="line"><span class="comment">// import Category from 'pages/category'</span></span><br><span class="line"><span class="comment">// import Personal from 'pages/personal'</span></span><br><span class="line"><span class="comment">// import Product from 'pages/product'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'pages/home'</span>),  <span class="comment">// 路由懒加载 ！！</span></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'home-product'</span>,</span><br><span class="line">        path: <span class="string">'product/:id'</span>,  <span class="comment">// 子路由开始不能加斜杠 / ！！</span></span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'pages/product'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'cart'</span>,</span><br><span class="line">    path: <span class="string">'/cart'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'pages/cart'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'category'</span>,</span><br><span class="line">    path: <span class="string">'/category'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'pages/category'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'personal'</span>,</span><br><span class="line">    path: <span class="string">'/personal'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'pages/personal'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,  <span class="comment">// 在输入的路由匹配不到的时候就会自动跳转home</span></span><br><span class="line">    redirect: <span class="string">'/home'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes  <span class="comment">// ES6写法</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="首页开发"><a href="#首页开发" class="headerlink" title="首页开发"></a>首页开发</h2><h3 id="结构、样式"><a href="#结构、样式" class="headerlink" title="结构、样式"></a>结构、样式</h3><p><code>App.vue</code> 中代码</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307165322924.png" alt="image-20200307165322924"></p>
<p>首页包裹在 <code>.g-view-container</code> 容器中</p>
<p>分析首页的组件： topbar、 backtop、以及中间的显示区域</p>
<p>同样，在home.vue 中先把位置信息写好</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307170210177.png" alt="image-20200307170210177"></p>
<p>然后在 <code>_container.scss</code> 中写各个container的样式</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307170251495.png" alt="image-20200307170251495"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307170256528.png" alt="image-20200307170256528"></p>
<p>然后在<code>home.vue</code> 中写一下大的 <code>class = home</code> 的样式</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307170333329.png" alt="image-20200307170333329"></p>
<h3 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h3><p>在 <code>components/home</code> 下新建 <code>header.vue</code> 子组件文件，这样维护起来就很方便了</p>
<p>这里把header抽象出一个基础组件，<strong>与业务逻辑无关的</strong>，具体里面放什么内容就通过插槽提供。</p>
<p>新建<code>src/base/index.vue</code> ，编写插槽</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307175432068.png" alt="image-20200307175432068"></p>
<p>在<code>pages/home/header.vue</code> 中使用</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307175648393.png" alt="image-20200307175648393"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200307175700193.png" alt="image-20200307175700193"></p>
<h4 id="解决导航条前面两个元素不存在时，消息图标不会在最右边"><a href="#解决导航条前面两个元素不存在时，消息图标不会在最右边" class="headerlink" title="解决导航条前面两个元素不存在时，消息图标不会在最右边"></a>解决导航条前面两个元素不存在时，消息图标不会在最右边</h4><p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200308171231487.png" alt="image-20200308171231487"></p>
<h3 id="导航条在其他页面样式"><a href="#导航条在其他页面样式" class="headerlink" title="导航条在其他页面样式"></a>导航条在其他页面样式</h3><p>购物车页面： 中间的文字是相对整个导航条居中的，并且超出文字会显示省略号</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200308171421547.png" alt="image-20200308171421547"></p>
<p>添加标题 h1 标签，并定义传入title属性才会显示</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200308172954084.png" alt="image-20200308172954084"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200308173043946.png" alt="image-20200308173043946"></p>
<p>附： ellipsis样式：</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200308173115738.png" alt="image-20200308173115738"></p>
<h2 id="幻灯片组件"><a href="#幻灯片组件" class="headerlink" title="幻灯片组件"></a>幻灯片组件</h2><p>借助Swiper来实现，但是swiper不是针对vue开发的，所以要使用 Vue-Awesome-Swiper</p>
<p>，基于Swiper4</p>
<p>下载<code>npm i --save vue-awesome-swiper</code> </p>
<p>在 <code>/home</code> 下创建幻灯片组件并引入</p>
<p>由于 幻灯片组件和业务关系不大，是很通用的基础组件，所以在base里再创建一个基础组件MeSlider</p>
<p>引入基础组件，我们要做： 在基础组件上面包装一层，填充相关数据变成 业务组件。</p>
<ol>
<li><p>新建 <code>base/slider/index.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309153021614.png" alt="image-20200309153021614"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309153344540.png" alt="image-20200309153344540"></p>
</li>
<li><p>创建 <code>home/slider.vue</code> 子组件</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309153605980.png" alt="image-20200309153605980"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309153615974.png" alt="image-20200309153615974"></p>
<p>把幻灯片相关的配置写到了 <code>home/config.js</code> 文件下了</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309153652924.png" alt="image-20200309153652924"></p>
</li>
</ol>
<h2 id="异步请求服务器端的数据"><a href="#异步请求服务器端的数据" class="headerlink" title="异步请求服务器端的数据"></a>异步请求服务器端的数据</h2><p>使用 axios，新建 <code>api/home.js</code> 专门处理 home页面下的请求</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309160827077.png" alt="image-20200309160827077"></p>
<p>然后在 <code>home/slider</code> 下使用接口，替换数据</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309160903028.png" alt="image-20200309160903028"></p>
<p>但是！ 现在会出现BUG： 明明开了无缝滚动，但是却没有效果</p>
<p>是因为在 异步数据 获取之前，就已经调用了基础slider组件，组件已经初始化了，里面没有数据也就是空空如也，那么就没有办法进行内部的运算，无缝滚动也就出现了BUG</p>
<p>解决办法： 等数据获取完成，再渲染slider组件。</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309161207112.png" alt="image-20200309161207112"></p>
<p>v-if：只有值为true的时候才会加载组件，和v-show的区别：v-show是先加载然后隐藏在DOM中，设置了 display=none</p>
<p>这样就可以正常显示了</p>
<p>最终添加错误处理后的 <code>api/home.js</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309162744305.png" alt="image-20200309162744305"></p>
<p><code>api/config.js</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309162804672.png" alt="image-20200309162804672"></p>
<h2 id="Loading-组件"><a href="#Loading-组件" class="headerlink" title="Loading 组件"></a>Loading 组件</h2><p>新建 <code>base/loading</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309170823584.png" alt="image-20200309170823584"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309170834545.png" alt="image-20200309170834545"></p>
<p>在 <code>home/slider.vue</code> 中使用</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200309171019961.png" alt="image-20200309171019961"></p>
<h2 id="滚动条组件"><a href="#滚动条组件" class="headerlink" title="滚动条组件"></a>滚动条组件</h2><p>滚动条组件是和业务无关的组件，创建 <code>base/scroll/index.vue</code>，在home组件中引入</p>
<p>滚动条使用的是<code>vue-awesome-swiper</code> 所以再scroll组件中引入</p>
<p>对于滚动条来说，swiper里面就只有一个swiperSlide，所有可以滚动的内容都在这个swiperSlide里面</p>
<p><code>base/scroll</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310135311380.png" alt="image-20200310135311380"></p>
<p>而且！ 可视区高度应该只是可视区的高度，不能被内容撑开，内容的高度可以很高</p>
<p><code>home/index.vue</code> 滚动条组件包裹所有内容</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310135418089.png" alt="image-20200310135418089"></p>
<p>然后需要设置样式：</p>
<p>可视区不让内容撑开，设置宽高为100%，让可视区撑开他父容器</p>
<p>然后内容高度为auto即可</p>
<p><code>base/scroll/index.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310135816270.png" alt="image-20200310135816270"></p>
<h2 id="导航面板"><a href="#导航面板" class="headerlink" title="导航面板"></a>导航面板</h2><p>新建 <code>home/nav/index.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310142051006.png" alt="image-20200310142051006"></p>
<p>使用flex布局</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310142058167.png" alt="image-20200310142058167"></p>
<h2 id="热卖推荐"><a href="#热卖推荐" class="headerlink" title="热卖推荐"></a>热卖推荐</h2><h3 id="jsonp封装"><a href="#jsonp封装" class="headerlink" title="jsonp封装"></a>jsonp封装</h3><p>npm安装 jsonp库</p>
<p>jspnp的API如下：</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310142429877.png" alt="image-20200310142429877"></p>
<p>我们要对它做一层封装： </p>
<ol>
<li>使用promise代替回调fn</li>
<li>支持传入data</li>
</ol>
<p><code>assets/js/jsonp.js</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200310144611377.png" alt="image-20200310144611377"></p>
<h3 id="从服务器端获取数据"><a href="#从服务器端获取数据" class="headerlink" title="从服务器端获取数据"></a>从服务器端获取数据</h3><p>在 <code>api/home.js</code>下暴露方法，供 <code>hone.vue</code> 获取热门推荐数据</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311005727099.png" alt="image-20200311005727099"></p>
<p><code>api/config.js</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311005836585.png" alt="image-20200311005836585"></p>
<p><code>recommend.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311005812363.png" alt="image-20200311005812363"></p>
<h3 id="结构和样式"><a href="#结构和样式" class="headerlink" title="结构和样式"></a>结构和样式</h3><p><code>home/recommend.vue</code></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311020543328.png" alt="image-20200311020543328"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311020557067.png" alt="image-20200311020557067"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311020608899.png" alt="image-20200311020608899"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311020621156.png" alt="image-20200311020621156"></p>
<h3 id="更新滚动条"><a href="#更新滚动条" class="headerlink" title="更新滚动条"></a>更新滚动条</h3><p>现在样式写完了，但是滚动条不能滚动了</p>
<p>是因为 数据是异步加载的，在滚动条组件加载完成的时候，数据还没有过来，所以滚动条无法计算现在的高度，就无法滚动，方法有2： </p>
<ol>
<li><p>通过传参数让滚动条自己更新</p>
</li>
<li><p>滚动条组件暴露一个API，在父组件可以调用方法更新滚动条</p>
<p>子组件<code>recommend</code>更新完数据冒泡，父组件<code>home</code>更新滚动条</p>
</li>
</ol>
<p>在 <code>recommend.vue</code> 中，通过 <code>$emit</code> 暴露loaded方法，传出recommends，原理就是子组件向父组件传值</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311022322905.png" alt="image-20200311022322905"></p>
<p>在 <code>home/index</code> 中接收事件</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311022550579.png" alt="image-20200311022550579"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311022610515.png" alt="image-20200311022610515"></p>
<p>首页接收到recommends后，给滚动条<code>me-scroll</code>传入 data数据，默认是一个空数据，当加载好之后就变成一个有值的数组，这样值发生了变化，就可以在 <code>me-scroll</code>中 watch变化，然后更新滚动条</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311022755180.png" alt="image-20200311022755180"></p>
<p><code>base/scroll/index</code></p>
<p>先接收传入的data</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311023210696.png" alt="image-20200311023210696"></p>
<p>watch数据的改变，改变后就调用update方法</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311023234572.png" alt="image-20200311023234572"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311023633287.png" alt="image-20200311023633287"></p>
<p>怎么获取swiper实例？ 传入ref值</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311023654259.png" alt="image-20200311023654259"></p>
<p><strong>伏笔： 这么写还有问题，现在还有没暴露出来， TODO</strong></p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>使用 <code>vue-lazyload</code> 插件</p>
<p>在 <code>main.js</code> 下注册</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311024509226.png" alt="image-20200311024509226"></p>
<p>使用的时候只需要把 <code>:src</code> 改成 <code>v-lazy</code> 就可以了</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311024618985.png" alt="image-20200311024618985"></p>
<h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><p>在滚动条组件中添加 loading 动画组件</p>
<p><code>base/scroll/index</code>  相对来说是父组件</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311130531470.png" alt="image-20200311130531470"></p>
<p>swiper提供监听下拉长度的事件，拉到100px就改变文字、刷新</p>
<p>在swiper的配置项里面使用 API</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311133230502.png" alt="image-20200311133230502"></p>
<p>添加scroll() 方法</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311133741551.png" alt="image-20200311133741551"></p>
<p><code>base/loading</code> 相对是子组件</p>
<p>添加修改文本的方法供父组件调用</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311133825686.png" alt="image-20200311133825686"></p>
<h2 id="松手刷新"><a href="#松手刷新" class="headerlink" title="松手刷新"></a>松手刷新</h2><p>监听松手事件，swiper提供了事件 touchEnd</p>
<p><code>base/scroll</code>  添加swiper原生事件</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311144437273.png" alt="image-20200311144437273"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311144506731.png" alt="image-20200311144506731"></p>
<p>然后在它的父组件 <code>home/index.vue</code> 中监听pull-down</p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311144648193.png" alt="image-20200311144648193"></p>
<p><img src="/2019/04/20/Vue%E5%9F%BA%E7%A1%80/image-20200311144729882.png" alt="image-20200311144729882"></p>
]]></content>
      <categories>
        <category>前端 - Vue</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Git</title>
    <url>/2019/12/28/git/</url>
    <content><![CDATA[<h1 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h1><p>生成命令：</p><p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p><h1 id="场景一：空仓库-amp-创建仓库提交代码"><a href="#场景一：空仓库-amp-创建仓库提交代码" class="headerlink" title="场景一：空仓库&amp;创建仓库提交代码"></a>场景一：空仓库&amp;创建仓库提交代码</h1><p>新建一个文件夹，执行 <code>git init</code>命令初始化一个本地仓库</p><a id="more"></a>


<p>这时会在文件夹中创建一个 <code>/.git/</code> 的文件夹</p>
<p>这个文件夹里面放的全部都是文件的<strong>快照</strong>，这些快照会有多个状态，git就是通过管理这些快照来对代码、文件进行版本管理的。</p>
<p>下面可以通过 <code>git add exampleFile</code>  命令添加文件到git的管理仓库里了</p>
<p>使用 <code>git status</code> 查看文件<strong>缓存</strong>的状态，有没有文件放在了待提交的区域</p>
<p>注： git有两种操作： <code>add</code> 、 <code>commit</code>  只有commit操作后才会拍一个快照，这个<strong>快照就是一次提交</strong></p>
<p><code>git commit -m &quot;first commit&quot;</code>  ， commit命令就把文件从缓存区提交到了本地仓库中，也就是一次快照。</p>
<p>这时再使用 <code>git status</code> 查看状态就会显示</p>
<p> <img src="/2019/12/28/git/image-20200419125654052.png" alt></p>
<p>此时如果使用 <code>git push origin master</code> ，会提示 不存在</p>
<p> <img src="/2019/12/28/git/image-20200419125706549.png" alt></p>
<p>因为origin（初始）是自己创建出来的，要使用<code>git remote</code>创建，来告诉git需要推送到哪个远程仓库上去</p>
<p><code>git remote add origin git@github.com:xx/learngit-1.git</code></p>
<p> <em>附： <code>git clone</code> 命令会自动设置好 origin</em></p>
<p>使用 <code>git remote add origin git@xx.com:xxx.git</code>，就可以push到远程仓库了</p>
<h1 id="场景二：-推送代码到多个仓库"><a href="#场景二：-推送代码到多个仓库" class="headerlink" title="场景二： 推送代码到多个仓库"></a>场景二： 推送代码到多个仓库</h1><p>可以使用 <code>git remote -v</code> 查看是否已经有远程仓库的地址</p>
<p>创景概述：</p>
<p>同一个本地git仓库，可以分别给不同的远程仓库提交，就需要设置不同的<code>origin</code>来做远程仓库的区分</p>
<p>新建一个空的远程仓库</p>
<p>并在本地git仓库中执行 <code>git remote add origin2 git@github.com:xxx/learngit-2.git</code></p>
<p>注意这里不再是 <code>origin</code> 而是设置为了 <code>origin2</code> </p>
<p> <img src="/2019/12/28/git/image-20200419130834029.png" alt></p>
<p><em>附：这里不同的远程仓库可以设置到同一个origin里面，这种适用于 一次推送想推送到多个仓库里面去，使用的是git remot里面的 set url指令来设置的。</em></p>
<p><em>但是不推荐这样做，因为一个仓库通常对应的是一个生产或发布的环境，那么就需要把一部分代码推送到正式的仓库中，也有一部分推送到自己或其他人的仓库。</em></p>
<p>然后就可以自己决定代码推送到哪一个远程仓库了</p>
<p><code>git push origin2 master</code></p>
<h1 id="快照管理"><a href="#快照管理" class="headerlink" title="快照管理"></a>快照管理</h1><p><code>git add xx</code> 命令是再工作区内对文件进行管理操作</p>
<p>本地会有一个 git的版本库</p>
<p>首先在本地 有些文件是没有被git仓库进行管理的，也有一些是已经管理过的（或提交过）</p>
<p>这时一个新文件做了一些新功能，就需要通过 <code>git add xx</code>命令添加到 本地版本库中的 临时管理区域(stage)中，这时git就开始监视这个文件了</p>
<p>当做了一次正式的提交操作后 <code>commit</code> ，这个文件就会变成一次快照</p>
<p><em>注：此时快照保存的是 文件的改变，而不是文件本身，否则git仓库会非常非常大</em></p>
<p> <img src="/2019/12/28/git/image-20200419131918056.png" alt></p>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p> <img src="/2019/12/28/git/image-20200419132512720.png" alt></p>
<p>可以看到之前的提交，是谁提交的，什么时候提交的，以及提交的日志，很重要</p>
<p>当需要进行 回滚 的时候，需要查看 hash值</p>
<h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p> <img src="/2019/12/28/git/image-20200419132642677.png" alt></p>
<p>主要是本地的提交，包括一些本地删除的提交，如果要撤回删除的提交，就可以使用 <code>git reflog</code>查看 hash值方便回退</p>
<h2 id="git-comfig"><a href="#git-comfig" class="headerlink" title="git comfig"></a>git comfig</h2><p>配置，查看全局配置 ： <code>git config --global --list</code></p>
<p> <img src="/2019/12/28/git/image-20200419133726337.png" alt></p>
<p>user.name 和 user.email 是必须要设置的，否则不能进行提交操作，如果没有设置，可以使用</p>
<p><code>git config --global user.name &quot;example name&quot;</code></p>
<p><code>git config --global user.email &quot;example@xx.com&quot;</code></p>
<h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><p>回退，顺便演示 <code>git log</code> 和 <code>git reflog</code>的区别和使用方法</p>
<p>首先新建 <code>321.txt</code>  并再进行一次新的提交</p>
<p> <img src="/2019/12/28/git/image-20200419133649723.png" alt></p>
<p>使用 <code>git log</code>查看</p>
<p> <img src="/2019/12/28/git/image-20200419133710364.png" alt></p>
<p>然后使用 <code>git reset</code> 命令回退到上一个版本，再使用git log查看时发现新版本就被删除掉了</p>
<p> <img src="/2019/12/28/git/image-20200419133920268.png" alt></p>
<p>但是使用 <code>git reflog</code> 就发现  仍然可以查看本地所有的操作日志</p>
<p> <img src="/2019/12/28/git/image-20200419134051346.png" alt></p>
<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><p>创建分支</p>
<p> <img src="/2019/12/28/git/image-20200419134328948.png" alt></p>
<p>这时仍然可以使用 <code>git reflog</code>查看本地所有操作，此时HEAD指向的是 master分支上，后面会多出来一个 dev 分支，这个dev分支前面没有origin，说明此时dev是一个本地分支</p>
<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><p>此时进行操作 <code>git checkout dev</code> 切换到了dev分支</p>
<p> <img src="/2019/12/28/git/image-20200419134705141.png" alt></p>
<p><code>git log</code> 只显示了当前指向了dev分支</p>
<p><code>git reflog</code> 则显示了在什么时候切换到的dev分支</p>
<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>假如修改一下 <code>123.txt</code>，使用 <code>git status</code> 就可以看到已经被监控的<code>123.txt</code>文件被修改的log</p>
<p>此时123的功能还没有开发完，不想提交到master分支上去</p>
<p>就可以使用 <code>git stash</code> </p>
<p> <img src="/2019/12/28/git/image-20200419135437517.png" alt></p>
<p>此时再使用 <code>git status</code> 就会发现变成了一个clean的工作区，而且此时123.txt文件内的修改会清空</p>
<p>这个文件的修改部分去哪了，怎么找回来？</p>
<p>使用 <code>git stash apply</code></p>
<p> <img src="/2019/12/28/git/image-20200419135718052.png" alt></p>
<p>文件就回来了</p>
<p><em>适用场景： 在一个分支上开发过程中，需要去别的分支看一眼，但是如果直接切换分支的话会提示有文件被修改，无法切换分支。这时就可以使用 git stash 把当前分支的状态缓存一下，就可以进行分支的切换了。想恢复就使用 git stash apply</em></p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>想查看当前分支下哪些文件发生了什么变化</p>
<p> <img src="/2019/12/28/git/image-20200419152847535.png" alt></p>
<h1 id="Git-Flow-（重点）"><a href="#Git-Flow-（重点）" class="headerlink" title="Git Flow （重点）"></a>Git Flow （重点）</h1><p>开发环境可能会有 自我测试环境、用户测试alpha、beta环境，正式环境</p>
<p>这里不讨论经典模型的问题</p>
<h2 id="1-适用于持续集成的模型"><a href="#1-适用于持续集成的模型" class="headerlink" title="1. 适用于持续集成的模型"></a>1. 适用于持续集成的模型</h2><p> <img src="/2019/12/28/git/image-20200419153451745.png" alt></p>
<p>在<code>master</code>分支上进行开发提交，一旦到版本需要发布的时候，就把代码合并到 <code>pre-production</code>分支上去，这样就算完成了一次测试提交了（预发布）</p>
<p>如果预发布版本没什么问题，就可以合并到 <code>production</code> 分支上了，production上的代码就自动进行构建</p>
<ul>
<li>适用于持续集成多环境场景</li>
<li>上游分支向下游发展</li>
</ul>
<p>流程：</p>
<p>Bug -&gt; New Branch -&gt; master -&gt; pre branch -&gt; Target Branch</p>
<h2 id="2-类Vue、React的模型"><a href="#2-类Vue、React的模型" class="headerlink" title="2. 类Vue、React的模型"></a>2. 类Vue、React的模型</h2><p> <img src="/2019/12/28/git/image-20200419154036502.png" alt></p>
<p>大家都在master分支上开发，当需要对master分支发布一个比较稳定的版本的时候，直接从master分支上新建一个分支出来，然后在这个分支上进行一些小的BUG修复</p>
<ul>
<li>适用于版本项目</li>
<li>稳定版本从master检出  bug修复在分支</li>
</ul>
<p>流程： master -&gt; Stable -&gt; new branch -&gt; bug fix -&gt;version</p>
<h2 id="演示-Vue的github"><a href="#演示-Vue的github" class="headerlink" title="演示 Vue的github"></a>演示 Vue的github</h2><p> <img src="/2019/12/28/git/image-20200419154417126.png" alt></p>
<p> <img src="/2019/12/28/git/image-20200419154428487.png" alt></p>
<p>Vue的github上，大家都是在dev分支上玩，然后直接从dev分支checkout版本分支出来</p>
<p>好处： 保证稳定的版本</p>
<h1 id="实操-git-flow"><a href="#实操-git-flow" class="headerlink" title="实操 git flow"></a>实操 git flow</h1><p>准备两个本地仓库，remote为同一个远程仓库的origin</p>
<p>拉取远程分支：</p>
<p><code>git pull origin master</code></p>
<p>假设这两个文件夹是两个不同的人在协同开发</p>
<p>那么两个人就需要商定：</p>
<p>每个人都在自己的 <code>dev</code> 分支上玩，<code>git branch</code> 查看分支，<code>git branch dev</code> 创建分支，就从master分支上检出（复制）了一份代码</p>
<p>因为在现实生活中，多人协作的时候，一般来说除了管理员，一般人是没有master分支的推送权限的，只能拉取</p>
<p><em>附： 快速创建并切换分支命令： <code>git checkout -b dev</code></em></p>
<p><em>注意：如果当前分支上有代码修改的话，是不允许切换到其他分支的。这时就需要经常使用 <code>git status</code> 命令查看当前分支的情况</em></p>
<p>现在，两个同事在各自的<code>dev</code>分支上 同时修改了 <code>123.txt</code>， 第一个同事 push 到 dev分支是可以正常推送的</p>
<p> <img src="/2019/12/28/git/image-20200419161047474.png" alt></p>
<p>但是当第一位同事推送过后，第二位同事再进行push，就会出现错误</p>
<p> <img src="/2019/12/28/git/image-20200419161203326.png" alt></p>
<p>提示说 远程的dev分支上已经有了一个<strong>本地尚不存在</strong>的提交</p>
<p>这时有两种方法</p>
<ol>
<li><p>大众做法，根据提示 使用 <code>git pull</code>，会自动执行合并</p>
<p>此时因为两位同事对同一个文件进行了修改，所以肯定会遇到合并冲突</p>
<p> <img src="/2019/12/28/git/image-20200419161449052.png" alt></p>
<p>使用 <code>git status</code> 查看一下状态，说双方都修改了 <code>123.txt</code></p>
<p> <img src="/2019/12/28/git/image-20200419161558245.png" alt></p>
<p>此时打开 <code>123.txt</code>文件，会出现git生成的分隔</p>
<p>上面的HEAD是本地本分支上的代码，下面就是远程代码的变化</p>
<p> <img src="/2019/12/28/git/image-20200419161753260.png" alt></p>
<p>此时修改好内容，保留本地的修改，然后执行 <code>git add 123.txt</code> <code>git commit</code></p>
<p>！ 此时再使用 <code>git status</code> 查看时发现当前是一个干净的分支</p>
<p> <img src="/2019/12/28/git/image-20200419162004499.png" alt></p>
<p>这时再push dev 就可以了</p>
<p> <img src="/2019/12/28/git/image-20200419162037595.png" alt></p>
</li>
<li><p>先进的解决办法 <code>git fetch</code></p>
<p>！ <code>git pull</code>命令相当于是 <code>git fetch</code> + <code>git merge</code></p>
<p><code>git fetch</code>命令只会拉取远程更新，但是不会把远程的更新合并到本地分支里面去。</p>
<p>简单说就是看一下远端分支和我本地分支有什么不一样</p>
<p> <img src="/2019/12/28/git/image-20200419162700091.png" alt></p>
<p>会提示远程有一个更新，现在已经把更新的内容放到了<code>FETCH_HEAD</code>中</p>
<p><code>git merge FETCH_HEAD</code> 就相当于合并两边的代码，就和直接使用 <code>git pull</code> 命令效果一样了。</p>
<p>如果 使用<code>git fetch origin feature:dev1</code> ，意思是把远端的feature分支合并到本地的 dev1分支上，如果dev1不存在，则会自动创建，并且此时 dev1分支上的代码就是 远端feature分支的代码了</p>
<p>此时再切换到 <code>dev</code> 分支上  使用 <code>git merge dev1</code> 就可以把代码合并到dev分支上来了</p>
<p>但是如果感觉远端的代码不好，又不想<code>merge</code>了怎么办？</p>
<p>使用 <code>git reset --hard head^</code> 回退到上一次提交的快照</p>
</li>
</ol>
<h1 id="两种工作流的实际操作"><a href="#两种工作流的实际操作" class="headerlink" title="两种工作流的实际操作"></a>两种工作流的实际操作</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>比如  现在有三个分支 <code>dev</code>  <code>feature</code>  <code>master</code> ， <code>feature</code> 分支为开发分支，<code>dev</code>为预发布分支</p>
<p>现在要把开发分支feature上的代码 发布到预发布分支dev上</p>
<p> <img src="/2019/12/28/git/image-20200421164947264.png" alt></p>
<p>首先使用 <code>git checkout</code> 命令切换到将要合并的分支也就是dev上，然后使用 <code>git merge</code> 命令合并分支上的内容</p>
<p> <img src="/2019/12/28/git/image-20200421165243448.png" alt></p>
<p>如果<code>feature</code> 分支上的内容和 <code>dev</code> 有冲突会提示的，没有冲突就会合并了</p>
<p>现在进行另一个操作： <code>dev</code>分支代码测试完成，需要把预发布分支<code>dev</code> 上的代码发布到正式/生产环境的分支<code>master</code>上</p>
<p>同样的操作，checkout到master分支，然后merge dev分支的代码即可。</p>
<p>注意就是需要 先切换到<strong>需要合并的分支</strong>上，再进行merge。</p>
<p> <img src="/2019/12/28/git/image-20200421165605527.png" alt></p>
<p>至此完成了 场景一 中的Git flow 工作流程。</p>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>第二种 基于版本的Git工作流需要使用一个很重要的概念就是 <code>git tag</code></p>
<p><code>git tag</code> 就是给当前分支的当前这次提交打上一个 tag</p>
<p> <img src="/2019/12/28/git/image-20200421170049950.png" alt></p>
<p><em>注意： 如果像之前一样只使用 <code>git push origin master</code> 推送只会推送代码，不会推送tag。如果想连同tag一起推送就需要在后面添加 <code>--tags</code> 参数</em></p>
<p>那么 添加<code>tag</code> 已经完成了，怎么删除本地tag呢？使用 <code>git tag -d vxxxx</code>删除</p>
<p> <img src="/2019/12/28/git/image-20200421170417469.png" alt></p>
<p>那么怎么删除远程tag呢？ <code>git push origin :refs/tags/v1.0.0</code></p>
<p> <img src="/2019/12/28/git/image-20200421170553813.png" alt></p>
<p>冒号<code>:</code> 代表前面没有任何分支的推送。</p>
<p>同样的，怎么删除远程分支呢？ 这里删除远程dev分支为例。</p>
<p><code>git push origin :dev</code></p>
<p> <img src="/2019/12/28/git/image-20200421170742118.png" alt></p>
<p>下面说一种场景的解决方法</p>
<p>没有完成代码的功能块，但是由于一些原因，把没有完成的功能代码进行了一次提交</p>
<p>本地还好，如果推送到了远程是很不利于code review的</p>
<p>这里除了之前说过的 <code>git stash</code> 缓存代码以外，还可以使用 <code>git reset</code>重置一些不必要的修改</p>
<p>如果使用 <code>git add .</code>  跟踪了不必要的文件：</p>
<p> <img src="/2019/12/28/git/image-20200421171508653.png" alt></p>
<p>git给了提示 使用 <code>git restore --staged &lt;file&gt;</code></p>
<p>另一种方法： 使用 <code>git reset HEAD &lt;file&gt;</code> 取消暂存</p>
<p> <img src="/2019/12/28/git/image-20200421172027861.png" alt></p>
<p>另一个场景：</p>
<p>怎么修改已经添加到版本库里面的文件的修改呢？也就是已经拍了快照的文件。</p>
<p>比如</p>
<p> <img src="/2019/12/28/git/image-20200421172504481.png" alt></p>
<p><code>feature add file.txt</code>文件是已经在版本库中的文件，在里面写了代码，但是感觉不好，怎么抛弃对它的修改？</p>
<p>同样提示 使用 <code>git restore &lt;file&gt;</code> 命令，还有一种方法就是使用 <code>git checkout -- &lt;file&gt;</code> </p>
<p> <img src="/2019/12/28/git/image-20200421172647387.png" alt></p>
<h1 id="Git-Flow-的意义"><a href="#Git-Flow-的意义" class="headerlink" title="Git Flow 的意义"></a>Git Flow 的意义</h1><p> <img src="/2019/12/28/git/image-20200421172955830.png" alt></p>
<h1 id="Branch分支的创建原则"><a href="#Branch分支的创建原则" class="headerlink" title="Branch分支的创建原则"></a>Branch分支的创建原则</h1><p> <img src="/2019/12/28/git/image-20200421173319262.png" alt></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2019/01/10/JavaScript/</url>
    <content><![CDATA[<h1 id="初识JavaScript"><a href="#初识JavaScript" class="headerlink" title="初识JavaScript"></a>初识JavaScript</h1><p>官方解释：JavaScript是一种基于对象和事件驱动的客户端脚本语言，最初的设计是为了检验HTML表单输入的正确性，起源于Netscape公司的LiveScript语言。</p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><a id="more"></a>
<p>Netscape和sun公司的开发联盟，名字由LiveScript改为JavaScript。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>完整的JavaScript 组成由</p>
<ol>
<li><p>ECMAScript（语法）</p>
<p>核心语言的语法。</p>
</li>
<li><p>Browser Object（DOM、BOM）（特性）</p>
<p>DOM: 访问和操作网页内容的方法与接口。</p>
<p>BOM: 提供与浏览器交互的方法和接口，比如打开浏览器窗口、缩放等。</p>
</li>
</ol>
<h2 id="在HTML中使用使用JavaScript"><a href="#在HTML中使用使用JavaScript" class="headerlink" title="在HTML中使用使用JavaScript"></a>在HTML中使用使用JavaScript</h2><p>可以在HTML <code>&lt;head&gt;</code>、<code>&lt;body&gt;</code>标签中使用 <code>&lt;script&gt;</code>嵌入JavaScript脚本。</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171255478.png" alt="image-20200530171255478"></p>
<h1 id="JS语法、变量"><a href="#JS语法、变量" class="headerlink" title="JS语法、变量"></a>JS语法、变量</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释 <code>//</code></p>
<p>多行注释 <code>/**/</code></p>
<p>语句结束使用分号<code>;</code>，如果省略，则由解析器确定语句的结尾。</p>
<p><strong>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。</strong></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>变量、函数、属性的名字，或者函数的参数。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol>
<li>由字母、数字、下划线、美元符组成</li>
<li>不能以数字开头</li>
<li>不能使用该关键字、保留字</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMACcript的变量是 <strong>松散类型</strong>，可以用来保存任何类型的数据，也就是说变量本身是没有类型的，类型是由变量的值来决定的。每个变量只是一个用于保存值得占位符而已。</p>
<h3 id="声明变量-var"><a href="#声明变量-var" class="headerlink" title="声明变量 var"></a>声明变量 var</h3><p> <code>var 变量名;</code></p>
<p>一次声明多个变量，使用逗号隔开：</p>
<p><code>var id, sex, age, name = &quot;marry&quot;;</code></p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p><code>var 变量名 = 值;</code>    <code>变量名 = 值</code></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ECMAScript 有5种基本数据类型，1种复杂数据类型。</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171417225.png" alt="image-20200530171417225"></p>
<h2 id="typeof-检测变量类型"><a href="#typeof-检测变量类型" class="headerlink" title="typeof 检测变量类型"></a>typeof 检测变量类型</h2><p>语法： <code>typeof 变量</code> 、 <code>typeof(变量)</code></p>
<p>返回值： string/number/boolean/object/undefined/function</p>
<h2 id="undefined-没有定义"><a href="#undefined-没有定义" class="headerlink" title="undefined    没有定义"></a>undefined    没有定义</h2><p>这种数据类型只有一个值，就是undefined。</p>
<p>一般而言，不存在需要显式地把一个变量设置为undefined字的情况。</p>
<p>举个例子，<code>var name;</code>  这里声明了name变量，但是没有赋值，这个时候变量name的数据类型就是undefined。</p>
<h2 id="null-空"><a href="#null-空" class="headerlink" title="null    空"></a>null    空</h2><ol>
<li>null值表示一个空的指针对象。</li>
<li>如果定义的变量准备在将来用于保存<strong>对象</strong>，那么最好将改变量初始化为null而不是其他值。</li>
</ol>
<p><strong>说明</strong>： undefined值是派生自null值的，所以undefined == null的返回结果是true。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>表示整数 和 浮点数</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN： 即非数值（Not a Number）是一个特殊的number数值。举个例子： <code>18-&quot;abc&quot;</code>，返回的结果就是NaN，本来是要返回数值的值，但是由于吗，某些原因返回不了数值类型的值，这个时候就会返回NaN。</p>
<p><code>typeof NaN;</code>  返回number</p>
<p><strong>NaN说明：</strong></p>
<ol>
<li>任何涉及NaN的操作（例如NaN/10），都会返回NaN。</li>
<li>NaN与任何值都不相等，包括NaN本身。</li>
</ol>
<p><strong>isNaN(n)</strong>: 检测n是否是 “非数值”，返回值： boolean.</p>
<p><strong>说明：</strong> isNaN() 对接收的数值，先尝试转换为数值，再检测是否为非数值。举个例子：<code>isNaN(&quot;18&quot;);</code> isNaN会先尝试把字符串类型的 “18” 转换成数值类型，发现可以转，就先转换再判断，返回了false.</p>
<h3 id="number数值转换"><a href="#number数值转换" class="headerlink" title="number数值转换"></a>number数值转换</h3><ol>
<li><p>Number() - 强制转换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">"18"</span>;</span><br><span class="line">id = <span class="built_in">Number</span>(id);  <span class="comment">// 强制转换为18</span></span><br><span class="line"><span class="comment">// 如果把非数字字符串强制转换为number，就会返回 NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parseInt() -  会忽略字符串前面的空格，直至找到第一个非空格字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> topval = <span class="string">"28px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(top - <span class="number">10</span>); <span class="comment">// NaN，不能减</span></span><br><span class="line"><span class="keyword">var</span> topval = <span class="built_in">parseInt</span>(<span class="string">"28px"</span>);  <span class="comment">// 转换成整型</span></span><br><span class="line"><span class="comment">// 但是必须要是以数字开头 才能提取，不是数字开头的话就会返回 NaN。</span></span><br></pre></td></tr></table></figure>

<p>第二个参数是 转换成多少进制，如： <code>parseInt(&quot;0xf&quot;, 16);</code></p>
</li>
<li><p>parseFloat() - 从第一个字符开始解析每个字符，直至遇见一个无效的浮点数学符为止</p>
<p>说明：除了第一个小数点有效外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="built_in">parseFloat</span>(<span class="string">"12.34px"</span>);  <span class="comment">// 12.34</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">parseInt</span>(<span class="string">"12.34px"</span>);  <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">parseFloat</span>(<span class="string">"12.34.56px"</span>);  <span class="comment">// 12.34</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">parseFloat</span>(<span class="string">"0123"</span>);  <span class="comment">// 123   忽略了0</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">parseInt</span>(<span class="string">"0123"</span>);  <span class="comment">// 123   忽略了0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>String类型用于表示由零个或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（” “）或单引号（’ ‘）表示。</p>
<h3 id="toString-与-String"><a href="#toString-与-String" class="headerlink" title="toString()与 String()"></a>toString()与 String()</h3><p>语法： str.toString(); 将str转换为字符串， 返回值：str的一个副本，参数：str是要转换的内容，可以是数值、布尔值、对象和字符串。</p>
<p>说明：在不知道要转换的值是不是null或者undefined的情况下，还可以使用String()函数，它能够将任何类型的值转换成字符串。</p>
<h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>有两个值， 真:true  ； 假: false</p>
<ol>
<li>除0之外所有数字，转换为布尔型都为true</li>
<li>除 “”之外的所有字符，转换为布尔型都为true</li>
<li>null、undefined转换为布尔型为false</li>
</ol>
<h1 id="表达式与操作符"><a href="#表达式与操作符" class="headerlink" title="表达式与操作符"></a>表达式与操作符</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>将同类型的数据（如常量、变量、函数等），用运算符号按一定的规则连接起来的、有意义的式子称为表达式。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h3><p>所有的算数操作符最后返回的都是number</p>
<p>在进行计算的时候，会把字符串类型的数字转换成数字，也就是会进行隐式类型转换。</p>
<p>+、-、*、/、%</p>
<p><code>+</code> 对数字是相加的作用，对字符串是有连接的作用</p>
<p>递增</p>
<p>​    ++a 先返回递增之后的a的值</p>
<p>​    a++先返回a的原值，再返回递增之后的值</p>
<p>递减</p>
<p>​    同递增</p>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>简单赋值： <code>=</code></p>
<p>复合赋值：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></p>
<h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>返回值：boolean</p>
<p><code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>==</code> 、 <code>===</code>、 <code>!=</code> 、 <code>!==</code></p>
<p>==： 相等，只比较值是否相等</p>
<p>===： 全等，比较值得同时比较数据类型是否相等</p>
<p>!==： 不相等，比较值是否不相等</p>
<p>!===： 不全等，比较值得同事比较数据类型是否不相等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == undefinded;  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === undefinded;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>语法： <code>条件 ? 执行代码1 : 执行代码2</code>，当条件成立时执行代码1，当条件不成立时执行代码2</p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>&amp;&amp;</code> 与、  <code>||</code>  或、 <code>!</code>  非</p>
<p>&amp;&amp; 与，两个条件都成立才为true，有一个不成立就是false</p>
<p>||或，两个条件都不成立才为false，有一个成立就是true</p>
<p>!非，取反</p>
<p>逻辑操作符在操作 非布尔 类型的数据的时候，返回的就不一定是 布尔 类型的值了</p>
<ol>
<li><p>如果第一个操作数不是布尔类型的，被隐式转换后为true，那么就返回 第二个操作数的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">80</span> &amp;&amp; <span class="number">50</span>  <span class="comment">// 55</span></span><br><span class="line"><span class="string">"hello"</span> &amp;&amp; <span class="number">65</span> &amp;&amp; <span class="string">"abc"</span>  <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果第一个操作数隐式类型转换后为false，则返回第一个操作数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> &amp;&amp; <span class="number">50</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="string">""</span> &amp;&amp; <span class="number">50</span>  <span class="comment">// 空字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有一个操作数是null，则返回null</p>
</li>
<li><p>如果有一个操作数是NaN，则返回NaN</p>
</li>
<li><p>如果有一个人操作数是undefined，则返回undefined</p>
</li>
</ol>
<p>逻辑与、逻辑或，都是 <strong>短路操作</strong>，即第一个条件如果可以决定结果，那么就不会再往下面继续执行了。</p>
<h4 id="逻辑非"><a href="#逻辑非" class="headerlink" title="! 逻辑非"></a>! 逻辑非</h4><ol>
<li><p>无论操作数是什么数据类型，逻辑非都会返回一个布尔值</p>
</li>
<li><p>!! 同时使用两个逻辑非操作符时：</p>
<p>第一个逻辑非操作会基于无论什么操作数返回一个布尔值</p>
<p>第二个逻辑非则对该布尔值求反</p>
</li>
</ol>
<h1 id="JS流程控制语句"><a href="#JS流程控制语句" class="headerlink" title="JS流程控制语句"></a>JS流程控制语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>做判断，语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单分支语句</span></span><br><span class="line"><span class="keyword">if</span>(condition条件)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双分支语句</span></span><br><span class="line"><span class="keyword">if</span>(condition条件)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多分支，js支持else if</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:statement</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value:statement</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(语句<span class="number">1</span>;语句<span class="number">2</span>;语句<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 被执行的代码块;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">语句1：在循环（代码块）开始前执行</span></span><br><span class="line"><span class="comment">语句2：定义运行循环（代码块）的条件</span></span><br><span class="line"><span class="comment">语句3：在循环（代码块）已被执行之后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;</span><br><span class="line">    需要执行的代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    wocument.write(i + <span class="string">'&lt;br /&gt;'</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    需要执行的代码;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件);</span><br><span class="line"><span class="comment">// 这种语法的训话你至少要被执行一次，先执行，再判断。</span></span><br></pre></td></tr></table></figure>



<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>立即退出循环</p>
<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>结束本次循环，继续开始下一次</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用<code>function</code> 关键字声明，后面跟一组参数以及函数体，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">[arg0, arg1,...,argn]</span>)</span>&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 说明：</span></span><br><span class="line"><span class="comment">1. functionName 是要定义的函数名，属于标识符，遵从标识符名称定义规则</span></span><br><span class="line"><span class="comment">2. []中的agr* 为函数的参数，[]里面的内容不是必须的，不是语法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">muFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"我是一个函数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">函数名([arg0, arg1,...,argn])</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>任何函数通过<code>return</code>语句，后面跟着返回的值来实现返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1+num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// return 的值就保存在了s里</span></span><br><span class="line"><span class="comment">/* 说明</span></span><br><span class="line"><span class="comment">1. 函数会在执行完return语句之后停止并立即退出</span></span><br><span class="line"><span class="comment">2. return语句也可以不带有任何返回值，用于提前停止函数执行又不需要返回值的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>所有的参数，在函数内都是数组的形式，也就是arguments对象来管理参数。</p>
<p>ECMAScript中的参数在内部用一个数组来表示，在函数体内通过argument对象来访问这个数组参数</p>
<p>说明：</p>
<ol>
<li>argument对象只是与数组类似，并不是Array的实例。</li>
<li>[]语法访问它的每一个元素</li>
<li>length属性确定传递参数的个数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num2);  <span class="comment">// undefinded</span></span><br><span class="line">&#125;</span><br><span class="line">inner(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arguments</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);  <span class="comment">//第一个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);  <span class="comment">//第二个参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);  <span class="comment">//undefined，因为没有传第三个参数</span></span><br><span class="line">&#125;</span><br><span class="line">inner(<span class="number">10</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在函数内部可以动态修改arguments对象里面的值，但是如果是JS的严格模式的话，就修改不了了。</p>
<h3 id="arguments对象的练习题，求任意一组数的平均值"><a href="#arguments对象的练习题，求任意一组数的平均值" class="headerlink" title="arguments对象的练习题，求任意一组数的平均值"></a>arguments对象的练习题，求任意一组数的平均值</h3><p>面试的时候经常遇到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求任意一组数的平均值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAvg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 对所有参数进行求和</span></span><br><span class="line">	<span class="keyword">var</span> sum = <span class="number">0</span>; len = <span class="built_in">arguments</span>.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		sum+=<span class="built_in">arguments</span>[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(sum/len);</span><br><span class="line">	<span class="keyword">return</span> sum/len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avg = getAvg(<span class="number">67</span>, <span class="number">89</span>, <span class="number">154</span>);</span><br></pre></td></tr></table></figure>



<h1 id="JS中的内置对象"><a href="#JS中的内置对象" class="headerlink" title="JS中的内置对象"></a>JS中的内置对象</h1><p>JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…</p>
<p>可以理解成浏览器自己封装好的对象，我们可以直接调用。</p>
<p>先来学Array、String、Math、Date四个。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>ECMAScript中的数组里面的每一项都可以保存任意类型的数据，数组的大小（长度）可以自动增长。</p>
<p>数组主要是用来存储一组数据的。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol>
<li><p>使用Array构造函数</p>
<p><code>new Array()</code>，小括号说明： 可以传入数组的长度、或者直接把组成项传进去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 传入数组的长度</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);  <span class="comment">// []</span></span><br><span class="line"><span class="comment">// 传入数组的包含项</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>);  <span class="comment">// [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数组字面量表示法</p>
<p>由一对包含数组项的方括号[]表示，多个数组项之间以逗号隔开。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>]</span><br></pre></td></tr></table></figure>

<h3 id="数组的读写"><a href="#数组的读写" class="headerlink" title="数组的读写"></a>数组的读写</h3><p>读取和设置值时，使用方括号[]并提供相应的索引。</p>
<p>说明：索引是从0开始的正整数。</p>
<p><code>console.log(cols[1]);</code> // 读取cols这个数组中索引为1的值</p>
<p>同样的，如果取的索引值大于数组的长度的话，就会取到undefined</p>
<h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h3><p>array.length</p>
<p>获取数组array的长度，返回值：number</p>
<ol>
<li>通过设置length可以从数组的末尾移除项或向数组中添加新项。</li>
<li>把一个值放在超出当前数组大小的位置上时，会重新计算数组长度值，长度等于最后一项索引加1。</li>
</ol>
<h3 id="数组的-栈方法"><a href="#数组的-栈方法" class="headerlink" title="数组的 栈方法"></a>数组的 栈方法</h3><ol>
<li><p>push()</p>
<p><code>arrayObject.push(newele1, newele2, ..., neweX)</code> </p>
<p>功能：把它的参数顺序添加到arrayObject的<strong>尾部</strong></p>
<p>返回值：把指定的值添加到数组后的新长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  colors = newArray(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="keyword">var</span> len = colors.push(<span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"black"</span>);  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);</span><br></pre></td></tr></table></figure>
</li>
<li><p>unshift()</p>
<p><code>arrayObject.unshift(newele1, newele2, ..., neweX)</code></p>
<p>功能：把它的参数顺序添加到arrayObject的<strong>开头</strong></p>
<p>返回值：把指定的值添加到数组后的新长度</p>
</li>
<li><p>pop()</p>
<p><code>arrayObject.pop()</code></p>
<p>功能：arrayObject的<strong>最后一个</strong>元素</p>
<p>返回值：被删除的那个元素</p>
</li>
<li><p>shift()</p>
<p><code>arrayObject.shift()</code></p>
<p>功能：arrayObject的<strong>第一个</strong>元素</p>
<p>返回值：被删除的那个元素</p>
</li>
</ol>
</li>
</ol>
<h3 id="join-数组转换字符串"><a href="#join-数组转换字符串" class="headerlink" title="join  数组转换字符串"></a>join  数组转换字符串</h3><p><code>arrayObject.join(separator)</code></p>
<p>功能：用于把数组中的所有元素放入一个字符串</p>
<p>返回值：字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> str = nums.join();  <span class="comment">// "2,4,5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = nums.join(<span class="string">'-'</span>);  <span class="comment">// "2-4-5"</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-数组重排序"><a href="#reverse-数组重排序" class="headerlink" title="reverse 数组重排序"></a>reverse 数组重排序</h3><p><code>arrayObject.reverse()</code></p>
<p>功能：用于颠倒数组中元素的顺序</p>
<p>返回值：数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">nums.reverse();  <span class="comment">// [5, 4, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-数组排序"><a href="#sort-数组排序" class="headerlink" title="sort 数组排序"></a>sort 数组排序</h3><p><code>arrayObject.sort(sortby)</code></p>
<p>功能：用于对数组的元素进行排序</p>
<p>返回值：数组</p>
<p>说明：</p>
<ol>
<li>即使数组中的每一项都是数值，sort()方法比较的也是字符串</li>
<li>sort()方法可以接收一个比较函数作为参数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">"border"</span>, <span class="string">"left"</span>, <span class="string">"color"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(words.sort());  <span class="comment">// ["border", "color", "left"] 按照首字母排序</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">88</span>,<span class="number">9</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">15</span>];</span><br><span class="line"><span class="comment">// sort 是把每一个数组项都调用了toString转成了字符串</span></span><br><span class="line">nums.sort();  <span class="comment">// [12,15,23,88,9]    按字符串来比较的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> b-a&#125;);</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="concat-连接两个或多个数组"><a href="#concat-连接两个或多个数组" class="headerlink" title="concat 连接两个或多个数组"></a>concat 连接两个或多个数组</h3><p><code>arrayObject.concat(arrayX,arrayX,...,ArrayX)</code></p>
<p>功能：用于连接两个或多个数组</p>
<p>返回值：数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], arr2=[<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="number">1</span>,<span class="number">3</span>],arr3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//concat</span></span><br><span class="line">arr3 = arr1.concat(arr2);  <span class="comment">// 把arr1和arr2连接在一起形成arr3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3);  <span class="comment">// ["a", "b", "c", "d", "e", 1, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="slice-截取"><a href="#slice-截取" class="headerlink" title="slice 截取"></a>slice 截取</h3><p>从已有的数组里返回一些元素</p>
<p><code>arrayObject.slice(start, end)</code></p>
<p>功能：从已有的数组中返回选定的元素</p>
<p>参数：</p>
<p>start（必需）规定从何处开始选取，如果是负数，则从数组尾部开始算起</p>
<p>end(可选)规定从何处结束选取，是数组片段结束处的数组下标</p>
<p>说明：</p>
<ol>
<li>如果没有指定end，切分的数组包含从start到数组结束的所有元素</li>
<li>如slice方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置</li>
</ol>
<p>返回值：</p>
<p>数组</p>
<h3 id="splice-操作数组"><a href="#splice-操作数组" class="headerlink" title="splice 操作数组"></a>splice 操作数组</h3><p><code>arrayObject.splice(index,count)</code></p>
<h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>功能：</p>
<p>删除从index处开始的零个或多个元素</p>
<p>返回值：</p>
<p>含有被删除的元素的数组</p>
<p>说明：</p>
<p>count是要删除的项目数量，如果设置为0，则不会删除项目。</p>
<p>如果不设置，则删除从index开始的所有值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>];</span><br><span class="line"><span class="keyword">var</span> delArr = arr.splice(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// (4) ["a", "b", "e", "f"]</span></span><br><span class="line"><span class="built_in">console</span>.log(delArr);  <span class="comment">// (2) ["c", "d"]</span></span><br></pre></td></tr></table></figure>

<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><code>arrayObject.splice(index,0,item1,...,itemX)</code></p>
<p>功能：</p>
<p>在指定位置插入值</p>
<p>参数：</p>
<p>index：起始位置</p>
<p>0:要删除的项数</p>
<p>item1…itemX:要插入的项</p>
<p>返回值：</p>
<p>空数组，操作原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>];</span><br><span class="line"><span class="keyword">var</span> insertArr = arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="string">"m"</span>,<span class="string">"n"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// (8) ["a", "b", "c", "m", "n", "d", "e", "f"]</span></span><br><span class="line"><span class="built_in">console</span>.log(insertArr);  <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p><code>arrayObject.splice(index,count,item1,...,itemX)</code></p>
<p>功能：</p>
<p>在指定位置插入值，且同时删除任意数量的项</p>
<p>参数：</p>
<p>Index：起始位置</p>
<p>count：要删除的项数</p>
<p>item1…itemX：要插入的项</p>
<p>返回值：从原数组中删除的项（如果没有删除任何项，则返回空数组）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> repalceArr = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>);  <span class="comment">// 从索引1开始，删除2个，再把后面的插入进去</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// (7) ["a", "x", "y", "z", "d", "e", "f"]</span></span><br><span class="line"><span class="built_in">console</span>.log(repalceArr);   <span class="comment">// (2) ["b", "c"]</span></span><br></pre></td></tr></table></figure>

<h3 id="下面两个是ECMAScript5中新增的数组方法"><a href="#下面两个是ECMAScript5中新增的数组方法" class="headerlink" title="下面两个是ECMAScript5中新增的数组方法"></a>下面两个是ECMAScript5中新增的数组方法</h3><p>说明：</p>
<ol>
<li><p>在比较第一个参数与数组中的每一项时，会使用全等操作符，即要求查找的项必须严格相等</p>
</li>
<li><p>数组的位置方法是ECMAScript5为数组实例新增的，所以支持的浏览器有：</p>
<blockquote>
<p>IE9 、Firefox、Safari、Opera、Chrome</p>
</blockquote>
</li>
</ol>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p><code>arrayObject.indexOf(searchvalue, startIndex)</code></p>
<p>功能：</p>
<p>从数组的开头（0）开始向后查找</p>
<p>参数：</p>
<p>searchvalue：必须，要查找的项；</p>
<p>startIndex：可选，起点位置的索引。</p>
<p>返回值：</p>
<p>number，查找的项在数组中的第一个位置，没有找到的情况下返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> pos = nums.indexOf(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">var</span> pos2 = nums.indexOf(<span class="number">99</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(pos2);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pos = nums.indexOf(<span class="number">7</span>, <span class="number">3</span>);  <span class="comment">// 设置了第二个参数：起始位置</span></span><br><span class="line"><span class="built_in">console</span>.log(pos);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="lastindexOf"><a href="#lastindexOf" class="headerlink" title="lastindexOf"></a>lastindexOf</h3><p><code>arrayObject.lastIndexOf(searchvalue, startIndex)</code></p>
<p>功能：</p>
<p>从数组的末尾开始向前查找</p>
<p>参数：</p>
<p>searchvalue： 必须，要查找的项</p>
<p>startIndex：可选，起点位置的索引</p>
<p>返回值：</p>
<p>number，查找的项在数组中的位置，没有找到的情况下返回-1</p>
<h3 id="如果想兼容IE9以下浏览器，自己封装方法："><a href="#如果想兼容IE9以下浏览器，自己封装方法：" class="headerlink" title="如果想兼容IE9以下浏览器，自己封装方法："></a>如果想兼容IE9以下浏览器，自己封装方法：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayIndexOf</span>(<span class="params">arr, value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 检测value在arr中出现的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,i&lt;arr.length,i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]===value)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="字符串-检索-方法"><a href="#字符串-检索-方法" class="headerlink" title="字符串 检索 方法"></a>字符串 检索 方法</h3><h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h4><p>语法：</p>
<p><code>stringObject.charAt(index)</code></p>
<p>功能：</p>
<p>返回stringObject中index位置字符的字符编码</p>
<p>说明：</p>
<p>从 <strong>ECMAScript5</strong> 中开始可以使用“方括号加字符索引“来访问字符串中特定的字符，但是IE7及更早的浏览器会返回undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(str[<span class="number">1</span>]);  <span class="comment">// e  ES5 新增，IE7以下不支持</span></span><br><span class="line">	<span class="built_in">console</span>.log(str.charAt(<span class="number">1</span>)); <span class="comment">// e 兼容性更好</span></span><br><span class="line">	<span class="built_in">console</span>.log(str.charAt(<span class="number">11</span>)); <span class="comment">// '' 取不到就返回空字符串</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(str.charCodeAt(<span class="number">1</span>));  <span class="comment">// 101 返回的是编码</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>语法：</p>
<p><code>stringObject.indexOf(&quot;o&quot;);</code></p>
<p>功能：</p>
<p>从一个字符串中搜索给定的子字符串，返回子字符串的位置</p>
<p>返回值：</p>
<p>说明：</p>
<p>如果没有找到该子字符串，则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> email = <span class="string">"marry@163.com"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(email.indexOf(<span class="string">"@"</span>));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(email.indexOf(<span class="string">"z"</span>));  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样可以检测一个子 字符串，不一定非要是单个的字符</span></span><br><span class="line"><span class="built_in">console</span>.log(email.indexOf(<span class="string">"rr"</span>));  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(email.indexOf(<span class="string">"aa"</span>));  <span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 并且只会检测第一个出现的位置，后面的就不再会去检测了</span></span><br></pre></td></tr></table></figure>

<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>语法：</p>
<p><code>string.Object.lastIndexOf(&quot;o&quot;)</code></p>
<p>功能：</p>
<p>从一个字符串中搜索给定的子字符串，返回子字符串的位置，效果同 indexOf，只不过是从字符串的结尾开始搜索。</p>
<p>返回值：</p>
<p>数值</p>
<p>说明：</p>
<p>如果没有找到该子字符串，则返回-1</p>
<h3 id="字符串-截取-方法"><a href="#字符串-截取-方法" class="headerlink" title="字符串 截取 方法"></a>字符串 截取 方法</h3><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>语法：</p>
<p><code>stringObject.slice(start, end);</code></p>
<p>功能：</p>
<p>截取子字符串。</p>
<p>参数说明：</p>
<ol>
<li>start：必需，指定子字符串的开始位置</li>
<li>end：可选，表示子字符串到哪里结束，end本身不在截取范围之内，省略的时候截取至末尾</li>
<li>当参数为负数时，会将传入的负值与字符串的长度相加。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">7</span>, <span class="number">10</span>));  <span class="comment">// orl</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">7</span>));  <span class="comment">// orld</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>));  <span class="comment">//  11 + -3 = 8  rld</span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">10</span>, <span class="number">7</span>));  <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>

<h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h4><p>说明： </p>
<p>语法及功能同slice()完全一样</p>
<p>区别在于：</p>
<ol>
<li>当参数为负数时，自动将参数转换为0.</li>
<li>substring() 会将较小的数作为开始位置，将较大的数作为结束位置。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">1</span>, <span class="number">4</span>));  <span class="comment">// ell</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-7</span>, <span class="number">5</span>));  <span class="comment">// hello  遇到负数就会转换为0</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>, <span class="number">-5</span>));  <span class="comment">// (0, 2)  he</span></span><br></pre></td></tr></table></figure>



<h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>语法：</p>
<p><code>stringObject.substr(start, len);</code></p>
<p>功能：</p>
<p>截取字符串</p>
<p>参数说明：</p>
<ol>
<li>start，必需，指定子字符串的开始位置。</li>
<li>len：可选，表示截取的字符总数，省略时截取至字符串的末尾</li>
<li>当start为负数时，会将传入的负值与字符串的长度相加</li>
<li>当len为负数时，返回空字符串</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">6</span>, <span class="number">3</span>));  <span class="comment">// wor</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-5</span>, <span class="number">4</span>));  <span class="comment">// worl</span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>, <span class="number">-4</span>));  <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串方法综合应用"><a href="#字符串方法综合应用" class="headerlink" title="字符串方法综合应用"></a>字符串方法综合应用</h3><p>编写js函数，用于获得输入参数的后缀名，如输入abc.txt，返回.txt</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取扩展名</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"index.html"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileFormat</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> indexCode = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">	<span class="keyword">if</span> (indexCode == <span class="number">-1</span>)&#123;<span class="keyword">return</span> <span class="literal">undefined</span>;&#125;</span><br><span class="line">	<span class="keyword">return</span> fileName.slice(indexCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> formatName = getFileFormat(url);</span><br><span class="line"><span class="built_in">console</span>.log(formatName);  <span class="comment">// .html</span></span><br></pre></td></tr></table></figure>

<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>语法：</p>
<p><code>string.Object.split(separator);</code></p>
<p>功能：</p>
<p>把一个 字符串 分割成 字符串数组 。</p>
<p>返回值：</p>
<p>Array</p>
<p>说明：</p>
<p>separator：必需，分隔符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'welcome-to-beijing'</span>;</span><br><span class="line">strArray = str.split(<span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(strArray);  <span class="comment">// (3) ["welcome", "to", "beijing"]</span></span><br></pre></td></tr></table></figure>

<h3 id="replece"><a href="#replece" class="headerlink" title="replece()"></a>replece()</h3><p>语法：</p>
<p><code>stringObject.replace(regexp/substr, replacement);</code></p>
<p>功能：</p>
<p>在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<p>返回值：</p>
<p>String</p>
<p>参数：</p>
<p>regexp：必需。规定子字符串或要替换的模式的RegExp对象。</p>
<p>replacement：必需。一个字符串值。</p>
<p><strong>注意：</strong></p>
<p>replace方法不会改变原字符串，返回的字符串需要变量接收。</p>
<h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a>toUpperCase()</h3><p>语法：</p>
<p><code>stringObject.toUpperCase()</code></p>
<p>功能：</p>
<p>把字符串转换为大写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase());  <span class="comment">// HELLO WORLD</span></span><br><span class="line"><span class="keyword">var</span> upper = str.charAt(<span class="number">6</span>).toUpperCase();</span><br><span class="line"><span class="built_in">console</span>.log(upper);  <span class="comment">// W</span></span><br></pre></td></tr></table></figure>



<h4 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a>toLowerCase()</h4><p>语法：</p>
<p><code>stringObject.toLowerCase()</code></p>
<p>功能：</p>
<p>把字符串转换为小写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">"WELCOME"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str2.toLowerCase());  <span class="comment">// welcome</span></span><br></pre></td></tr></table></figure>



<p>用处：</p>
<p>在JS中，很多时候需要设置  <code>border-left-color</code> ，这种CSS样式，但是在JS中的写法就变成了 <code>borderLeftColor</code> 驼峰形式，下面就来封装一下转驼峰写法的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转驼峰写法的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelback</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> attrArray = attr.split(<span class="string">'-'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; attrArray.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> str = attrArray[i];</span><br><span class="line">        <span class="keyword">var</span> newStr = str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line">        attrArray[i] = newStr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> attrArray.join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> camelFormat = camelback(<span class="string">"border-left-color"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(camelFormat); <span class="comment">// borderLeftColor</span></span><br></pre></td></tr></table></figure>



<h2 id="常用-Math-对象"><a href="#常用-Math-对象" class="headerlink" title="常用 Math 对象"></a>常用 Math 对象</h2><h3 id="Math-min"><a href="#Math-min" class="headerlink" title="Math.min()"></a>Math.min()</h3><p>语法：</p>
<p><code>Math.min(num1, num2,...,numN)</code></p>
<p>功能：</p>
<p>求一组数中的最小值</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">5</span>,<span class="number">-4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">108</span>,<span class="number">-55</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// -55</span></span><br><span class="line"><span class="comment">// 只要这组数字中出现了非数字，那么返回的就是 NAN</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">5</span>,<span class="number">-4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">108</span>,<span class="number">-55</span>,<span class="string">"qwe"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);  <span class="comment">// NAN</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h3><p>语法：</p>
<p><code>Math.max(num1, num2,...,numN)</code></p>
<p>功能：</p>
<p>求一组数中的最大值</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">5</span>,<span class="number">-4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">108</span>,<span class="number">-55</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// 108</span></span><br><span class="line"><span class="comment">// 只要这组数字中出现了非数字，那么返回的就是 NAN</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">5</span>,<span class="number">-4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">108</span>,<span class="number">-55</span>,<span class="string">"qwe"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);  <span class="comment">// NAN</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h3><p>语法：</p>
<p><code>Math.ceil(num)</code></p>
<p>功能：</p>
<p>向上取整，即返回大于num的最小整数。</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Math.ceil()</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">189.99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// 189.99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(num));  <span class="comment">// 190</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h3><p>语法：</p>
<p><code>Math.floor(num)</code></p>
<p>功能：</p>
<p>向下取整，返回num的整数部分。</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Math.floor()</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">189.99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// 189.99</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(num));  <span class="comment">// 189</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h3><p>语法：</p>
<p><code>Math.round(num)</code></p>
<p>功能：</p>
<p>将数值四舍五入为最接近的整数。</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">189.50</span>));  <span class="comment">// 190</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">189.49</span>));  <span class="comment">// 189</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h3><p>可以用在移动端判断用户滑动的距离</p>
<p>语法：</p>
<p>Math.abs(num)</p>
<p>功能：</p>
<p>返回num的绝对值</p>
<p>返回值：</p>
<p>Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = <span class="number">-55</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(nums));  <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>

<h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>语法：</p>
<p><code>Math.random()</code></p>
<p>功能：</p>
<p>返回大于等于0小于1的一个随机数   <strong>0~1</strong></p>
<p>最小值：0    最大值：0.999999999…</p>
<p>返回值：</p>
<p>Number</p>
<p>说明：</p>
<p>求n到m之间的随机整数的公式：</p>
<p><code>random = Math.floor(Math.random()*(m-n+1)+n)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// random</span></span><br><span class="line"><span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line"><span class="built_in">console</span>.log(random);  <span class="comment">// 0~1 之间随机的数</span></span><br></pre></td></tr></table></figure>

<h3 id="自己封装以个生成n-m之间随机整数的函数"><a href="#自己封装以个生成n-m之间随机整数的函数" class="headerlink" title="自己封装以个生成n-m之间随机整数的函数"></a>自己封装以个生成n-m之间随机整数的函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己封装以个生成n-m之间随机整数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">n, m</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> choice = m-n+<span class="number">1</span>;  <span class="comment">// 随机整数的个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*choice+n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> random1 = getRandom(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(random1);</span><br></pre></td></tr></table></figure>

<h2 id="date对象"><a href="#date对象" class="headerlink" title="date对象"></a>date对象</h2><p>用于创建日期时间的对象</p>
<ol>
<li>掌握<strong>创建</strong>日期对象的方法</li>
<li>掌握date对象中<strong>获取</strong>日期时间的方法</li>
<li>掌握date对象中<strong>设置</strong>日期时间的方法</li>
</ol>
<h3 id="创建一个日期对象"><a href="#创建一个日期对象" class="headerlink" title="创建一个日期对象"></a>创建一个日期对象</h3><p>语法：</p>
<p><code>new Date();</code></p>
<p>功能：</p>
<p>创建一个日期时间对象</p>
<p>返回值：</p>
<p>不传参的情况下，返回当前的日期时间对象。</p>
<p><strong>说明：</strong></p>
<p>如果想根据特定的日期和事件创建日期对象，必须传入表示该日期的毫秒数 或者 是一组用逗号隔开的表示年月日时分秒的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个日期对象</span></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(today);  <span class="comment">// Thu Nov 07 2019 17:47:27 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种做法</span></span><br><span class="line"><span class="keyword">var</span> year = today.getFullYear();</span><br><span class="line"><span class="keyword">var</span> month = today.getMonth();</span><br><span class="line"><span class="keyword">var</span> day = today.getDate();</span><br><span class="line"><span class="comment">// 创建了一个目标日期对象</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Date</span>(year, month, day+<span class="number">50</span>);  <span class="comment">// 注意传参 小时分秒不传的话也没错</span></span><br></pre></td></tr></table></figure>



<h3 id="获取-年月日时分秒-及-星期-的方法"><a href="#获取-年月日时分秒-及-星期-的方法" class="headerlink" title="获取 年月日时分秒 及 星期 的方法"></a>获取 年月日时分秒 及 星期 的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> weeks = [<span class="string">"日"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span>]</span><br><span class="line">year = today.getFullYear(),</span><br><span class="line">    </span><br><span class="line">month = today.getMonth(),</span><br><span class="line">    </span><br><span class="line">date = today.getDate(),</span><br><span class="line">    </span><br><span class="line">week = today.getDay(),</span><br><span class="line">    </span><br><span class="line">hours = today.getHours(),</span><br><span class="line">    </span><br><span class="line">minutes = today.getMinutes(),</span><br><span class="line">    </span><br><span class="line">seconds = today.getSeconds(),</span><br><span class="line">    </span><br><span class="line">times = today.getTime(),</span><br><span class="line">    </span><br><span class="line">time = year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + date + <span class="string">"日"</span> + hours + <span class="string">"时"</span> + minutes + <span class="string">"分"</span> + seconds + <span class="string">"秒  星期"</span> + weeks[week];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"现在是："</span> + time);  <span class="comment">// 现在是：2019年10月7日17时53分58秒</span></span><br><span class="line"><span class="built_in">console</span>.log(times);  <span class="comment">// 1573120731008</span></span><br></pre></td></tr></table></figure>

<h3 id="设置年月日时分秒及星期的方法"><a href="#设置年月日时分秒及星期的方法" class="headerlink" title="设置年月日时分秒及星期的方法"></a>设置年月日时分秒及星期的方法</h3><p><img src="/2019/01/10/JavaScript/image-20200530171542693.png" alt="image-20200530171542693"></p>
<p>​    </p>
<h3 id="小例子：-50天之后是星期几"><a href="#小例子：-50天之后是星期几" class="headerlink" title="小例子： 50天之后是星期几"></a>小例子： 50天之后是星期几</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 50天之后是星期几</span></span><br><span class="line">today.setDate(today.getDate() + <span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(today.getDay());</span><br></pre></td></tr></table></figure>



<h1 id="JavaScript-错误处理"><a href="#JavaScript-错误处理" class="headerlink" title="JavaScript 错误处理"></a>JavaScript 错误处理</h1><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>简单说，语法错误就是不符合JS语法的错误。出现语法错误，控制台会进行报错并告知出错的行号（但行号不一定准确）。</p>
<p>常见的语法错误：</p>
<ul>
<li>符号漏打，多打，少打，错打</li>
<li>使用了不合语法的变量名</li>
<li>语句写错，没写完等</li>
</ul>
<p>浏览器会提示出代码的第一处错误，并且停止运行。</p>
<h2 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h2><ul>
<li><p><strong>ReferenceError</strong>  常见于变量名未声明</p>
<p><code>Uncaught ReferenceError: foo is not defined</code> </p>
</li>
<li><p><strong>TypeError</strong>  类型错误，常发生的两种情况</p>
<ol>
<li>获取未初始化的变量的属性或方法</li>
<li>调用类型错误</li>
</ol>
<p><code>Uncaught TypeError: Cannot read property &#39;length&#39; of undefined</code></p>
</li>
<li><p><strong>RangeError</strong> 调用栈溢出，递归深度过大就会报错</p>
<p><code>error.html:16 Uncaught RangeError: Maximum call stack size exceeded</code></p>
<p>调用栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在计算机每次遇到 函数内部的调用函数的时候，会把当前的函数的状态保存下来，之前的函数并没有结束</span></span><br><span class="line"><span class="comment">// 调用栈就是 很多函数都没有结束，是一个等待的有序序列，这个序列就称为调用栈</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n + S(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="区分语法错误与运行时错误"><a href="#区分语法错误与运行时错误" class="headerlink" title="区分语法错误与运行时错误"></a>区分语法错误与运行时错误</h2><p>对于新手来说，语法错误跟运行时错误在仅看代码的情况下不太容易区分。</p>
<p>一个简单的区分方法：</p>
<ul>
<li>语法错误无论如何都不可能运行成功</li>
<li>运行时错误是有可能运行成功的</li>
</ul>
<h2 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h2><p>逻辑错误一般 指的是 计算结果不符合预期。</p>
<p>如何调试？： 单步调试。</p>
<p>在代码中输入  <code>debugger;</code>  浏览器在运行代码，遇到debugger的时候就会暂停，打开控制台，会出现调试工具。</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171600091.png" alt="image-20200530171600091"></p>
<p>可以在Watch中输入需要监控的变量名</p>
<p>按钮功能：</p>
<ul>
<li>Resume script execution，恢复代码运行，代码会开始执行直到下一次遇到 debugger</li>
<li>Step over next function call，跳过下一个函数的调用，把函数当做一行代码来执行</li>
<li>Step into next function call，进到函数内部一步一步看函数是怎么执行的</li>
<li>Step out next function call</li>
</ul>
<h2 id="主动触发一个错误"><a href="#主动触发一个错误" class="headerlink" title="主动触发一个错误"></a>主动触发一个错误</h2><p><strong>throw</strong> 语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 如果a b参数的类型不对，就主动触发错误  throw</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">typeof</span> a != <span class="string">'number'</span>) || (<span class="keyword">typeof</span> b != <span class="string">'number'</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'自定义错误，参数数据类型不对'</span>);</span><br><span class="line">        <span class="comment">// error.html:33 Uncaught Error: 自定义错误，参数数据类型不对</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果传入的参数不是数字，怎么办？</span></span><br><span class="line">multiple(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>发生不可避免的错误时怎么办？</p>
<p>某些运行时错误不可避免，那么就可以使用 try catch 语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiple</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 如果a b参数的类型不对，就主动触发错误  throw</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">typeof</span> a != <span class="string">'number'</span>) || (<span class="keyword">typeof</span> b != <span class="string">'number'</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'自定义错误，参数数据类型不对'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果传入的参数不是数字，怎么办？</span></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 如果内部的代码抛出错误，则代码直接跳入catch块运行，且把错误对象赋值给catch括号内的变量</span></span><br><span class="line">	multiple(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"没出错执行我。"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"出错了执行我。"</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(e);  <span class="comment">// console.log(e);</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 不管有没有错，最终finally里的语句都会执行</span></span><br><span class="line">	<span class="comment">// 可以在里面做一些  清理性的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="try-catch-的坑"><a href="#try-catch-的坑" class="headerlink" title="try-catch 的坑"></a>try-catch 的坑</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo());  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h1 id="不污染Window环境的JS"><a href="#不污染Window环境的JS" class="headerlink" title="不污染Window环境的JS"></a>不污染Window环境的JS</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使JS代码就在这个作用域下执行，不污染Window环境</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h1 id="DOM节点操作"><a href="#DOM节点操作" class="headerlink" title="DOM节点操作"></a>DOM节点操作</h1><p>大体有 增删改查</p>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><h3 id="document-write"><a href="#document-write" class="headerlink" title="document.write()"></a>document.write()</h3><p><code>document.write(&quot;&lt;h1&gt;You are my sunshine.&lt;/h1&gt;&quot;);</code></p>
<p>可以创建节点，但是缺点很明显</p>
<ol>
<li>因为 document.write 写入文档流，在关闭(已加载)的文档上调用 document.write 会自动调用 document.open，这将清除该文档。</li>
<li>向一个已经加载，并且没有调用过document.open()的文档写入数据时，会自动完成调用document.open()的操作。一旦完成了数据写入，系统要求调用document.close()，以告诉浏览器页面已经加载完毕。写入的数据会被解析到文档结构模型里。在上面的例子里，元素h1会成为文档中的一个节点。</li>
<li>如果document.write()被直接嵌入到HTML主体代码中，那么它将不会调用document.open()。</li>
</ol>
<p>所以不推荐使用，推荐使用 W3C的 DOM API，下面学  4 种</p>
<h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><h3 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// 创建节点、文本</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(<span class="string">'Item'</span>);</span></span><br><span class="line">	li.appendChild(txt);</span><br><span class="line">	ul.appendChild(li);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>document.createElement 还能支持创建当前浏览器不支持的标签名，在IE6-8下，这是一个著名的hack。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!</span><br><span class="line">		<span class="comment">// 下面代码的意思：如果是ie才会执行 /*@cc_on@*/里面的代码，也就是一个叹号</span></span><br><span class="line">		<span class="comment">// 那么ie下运行就是假，其他浏览器就是真。</span></span><br><span class="line">		<span class="comment">/*@cc_on!@*/</span></span><br><span class="line">	<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 使JS代码就在这个作用域下执行，不污染Window环境</span></span><br><span class="line">	<span class="keyword">var</span> e = <span class="string">"abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, nav, output, progress, section, time, video"</span>.split(<span class="string">', '</span>);</span><br><span class="line">	<span class="keyword">var</span> i = e.length;</span><br><span class="line">	<span class="keyword">while</span> (i--) &#123;</span><br><span class="line">		<span class="built_in">document</span>.createElement(e[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加上这些代码以后，在ie下也就可以使用这些 标签了 。</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h3 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h3><p>创建文档片段</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// 创建节点、文本</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">var</span> li = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">		li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">		li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item"</span> + (i+<span class="number">1</span>)));</span></span><br><span class="line">		fragment.appendChild(li);</span><br><span class="line">	&#125;</span><br><span class="line">	ul.appendChild(fragment);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h3><p>创建注释节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// 创建节点、文本</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">"A comment"</span>);</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">var</span> li = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="actionscript">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">		li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">		li.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">"Item"</span> + (i+<span class="number">1</span>)));</span></span><br><span class="line">		fragment.appendChild(li);</span><br><span class="line">	&#125;</span><br><span class="line">	ul.appendChild(fragment);</span><br><span class="line"><span class="actionscript">	<span class="comment">// 第一个参数：要插入的节点  第二个参数：要插入的节点的相对的位置</span></span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.body.insertBefore(comment, ul);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="高效创建节点"><a href="#高效创建节点" class="headerlink" title="高效创建节点"></a>高效创建节点</h2><p>如果需要插入大量的HTML标记的情况下，通过create系列仍然非常麻烦</p>
<p>因为不仅要创建，而且要按照顺序排列</p>
<p>使用插入标记技术，直接插入HTML字符串不仅更简单，而且速度更快。</p>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>用来设置或获取当前标签的起始和结束里面的内容</p>
<p>返回调用元素的所有节点，包括元素节点、注释节点、文本节点和对应的HTML标记</p>
<p>在写模式下，会根据指定的值创建一个DOM树，用这个DOM树完全替换之前的所有子节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;ul&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 1&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 2&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 3&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line"></span><br><span class="line">content.innerHTML = str;</span><br><span class="line">alert(content.innerHTML);</span><br></pre></td></tr></table></figure>

<p>使用innerHTML的限制</p>
<p>字符串的最左边不能出现空白，IE6-8会自动移除掉它</p>
<p>IE、欧朋 会将所有的标签转换为大写形式</p>
<p>Safari、Firefox、Chrome  会返回原本的小写形式</p>
<p>大多数浏览器不会对script标签进行脚本执行操作</p>
<p>不能单独创建meta，style，link等元素，一定要在前面加上一些字符。</p>
<h3 id="outerHTML"><a href="#outerHTML" class="headerlink" title="outerHTML"></a>outerHTML</h3><p>返回调用它的元素及所有子节点的HTML标签</p>
<p>在写 模式下，会根据指定的HTML字符串创建新的outer子树，然后用这个outer子树完全替换调用的元素</p>
<p>支持outerHTML的浏览器：</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171621165.png" alt="image-20200530171621165"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with a list following it.&lt;/p&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;ul&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 1&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 2&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;li&gt;Item 3&lt;/li&gt;"</span></span><br><span class="line">+ <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">content.innerHTML = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印的结果是从div节点（添加的节点的外部一层）开始，包含子元素。</span></span><br><span class="line"><span class="comment">// innerHTML 却不包含外部的div节点</span></span><br><span class="line"><span class="built_in">console</span>.log(content.outerHTML);</span><br><span class="line">content.outerHTML = <span class="string">"&lt;p&gt;This is a paragraph.&lt;/p&gt;"</span>;  <span class="comment">// 这么写的话  原来的div就不存在了，而是替换成了一个新的</span></span><br></pre></td></tr></table></figure>

<h3 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h3><p>设置或获取位于对象起始和结束标签内的文本</p>
<p>包括 子文档数中的文本。</p>
<p>通过innerText读取的时候，会根据由浅入深的顺序将子文档树中的所有文本拼接起来</p>
<p>再通过innerText写入值的时候，会删除元素的所有子节点，插入包含相应文本值的文本节点。</p>
<p>浏览器兼容性：</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171635539.png" alt="image-20200530171635539"></p>
<p>Firefox不支持，支持作用类似的textContent 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(content.innerText);  <span class="comment">// 只返回文本，没有标签</span></span><br><span class="line">content.innerText = <span class="string">"&lt;p&gt;This is a paragraph.&lt;/p&gt;"</span>  <span class="comment">// 写入的事原本的文本内容，包括标签文本。</span></span><br></pre></td></tr></table></figure>

<p>通用脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) ? element.textContent : element.innerText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInnerText</span>(<span class="params">element, text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> element.textContent == <span class="string">"string"</span>) &#123;</span><br><span class="line">        element.textContent = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        element.innerText = text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="outerText"><a href="#outerText" class="headerlink" title="outerText"></a>outerText</h3><p>除了 作用范围 扩大到了包含调用它的节点之外，outerText与 innerText基本没什么区别。</p>
<p>在读取文本的时候，outerText与innerText的结果是完全一样的。</p>
<p>在写模式下，outerText不止替换子节点，还会替换整个元素，包括子节点。</p>
<p><strong>由于这个属性会导致调用它的元素不存在，因此并不常用，不推荐使用。</strong></p>
<h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><h3 id="节点遍历"><a href="#节点遍历" class="headerlink" title="节点遍历"></a>节点遍历</h3><p>DOM是呈现为一个树状结构的，因此节点之间存在 上下左右 的关系。</p>
<p><img src="/2019/01/10/JavaScript/image-20200530171653990.png" alt="image-20200530171653990"></p>
<h4 id="第一种方法：-家族"><a href="#第一种方法：-家族" class="headerlink" title="第一种方法： 家族"></a>第一种方法： 家族</h4><p><img src="/2019/01/10/JavaScript/image-20200530171708357.png" alt="image-20200530171708357"></p>
<p>查找方法见代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oHtml = <span class="built_in">document</span>.documentElement;  <span class="comment">// documentElement属性 返回文档的根节点</span></span><br><span class="line"><span class="comment">// tagName属性 返回元素的标签名</span></span><br><span class="line"><span class="built_in">console</span>.log(oHtml.tagName);  <span class="comment">// HTML</span></span><br><span class="line"><span class="comment">// 获取head元素</span></span><br><span class="line"><span class="keyword">var</span> oHead = oHtml.firstChild;</span><br><span class="line"><span class="built_in">console</span>.log(oHead);  <span class="comment">// head 节点</span></span><br><span class="line"><span class="keyword">var</span> oHead = oHtml.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(oHead);  <span class="comment">// head 节点</span></span><br><span class="line"><span class="keyword">var</span> oHead = oHtml.childNodes.item(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(oHead);  <span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找body元素，它是html的第二个子元素</span></span><br><span class="line"><span class="keyword">var</span> oBody = oHtml.childNodes[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 解释：#text是文本节点，是因为现代的标准浏览器会将两个节点中间的空格也视作文本节点。</span></span><br><span class="line"><span class="built_in">console</span>.log(oBody);  <span class="comment">// #text</span></span><br><span class="line"><span class="keyword">var</span> oBody = oHtml.childNodes.item(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(oBody);  <span class="comment">// #text</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找父节点</span></span><br><span class="line"><span class="built_in">console</span>.log(oHead.parentNode == oHtml);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 兄弟节点之间的查找</span></span><br><span class="line"><span class="built_in">console</span>.log(oBody.previousSibling == oHead);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(oHead.nextSibling == oBody);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 祖先节点</span></span><br><span class="line"><span class="built_in">console</span>.log(oBody.ownerDocument);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否存在子节点</span></span><br><span class="line"><span class="built_in">console</span>.log(oBody.hasChildNodes());  <span class="comment">// true/false</span></span><br></pre></td></tr></table></figure>

<p>上方代码存在的问题：</p>
<p>会把代码的换行，也看作是一个文本节点，导致在换行的地方存在空白子节点。</p>
<p>也就是说API会把空白节点也纳入了子节点的计算中。</p>
<p>之前的方法： 1. 去掉空白节点。 2.判断这个节点是否为空。都不是很好的方法。</p>
<p>现在有更好的方法：</p>
<h4 id="一些更好用的属性"><a href="#一些更好用的属性" class="headerlink" title="一些更好用的属性"></a>一些更好用的属性</h4><p> <code>childElementCount</code>  ：这个属性里面包含的节点不包括空白的文本节点。</p>
<p><code>children</code>：可以与上一个属性联用，同样不会读取到父元素的空白文本节点。</p>
<p>但是注意：<strong>IE8及以下浏览器不支持。</strong></p>
<p><strong>节点遍历案例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历节点案例</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">""</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">space, node</span>) </span>&#123;  <span class="comment">// space:节点之间分割的字符串   node：遍历的当前节点</span></span><br><span class="line">	<span class="keyword">if</span> (node.tagName) &#123;  <span class="comment">// 如果当前节点是标签，就直接拼接字符串</span></span><br><span class="line">		s += space + node.tagName + <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> len = node.childNodes.length;  <span class="comment">// 保存当前节点的子节点的个数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; len; i++)&#123;  <span class="comment">// 遍历节点的子节点</span></span><br><span class="line">		travel(space+<span class="string">"|-"</span>, node.childNodes[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">travel(<span class="string">""</span>, <span class="built_in">document</span>);</span><br><span class="line"><span class="built_in">document</span>.write(s);</span><br></pre></td></tr></table></figure>

<h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><h4 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h4><p>之前提到，每个节点都有一个 <code>childNodes</code> 属性，这个属性保存着一个<code>NodeList</code> 对象。</p>
<ul>
<li>NodeList 是一种类数组对象，用于保存一组有序的节点</li>
<li>可以通过方括号语法访问NodeList的值，有item方法与length属性</li>
<li>它并不是Array的实例，没有数组对象的方法</li>
</ul>
<p>把 类数组对象转换为 数组对象，有两种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 将NodeList转换成数组</span></span><br><span class="line"><span class="comment">// 这样两种方法都是只能把 类数组对象 NodeList 转换成数组对象，但是并不能在DOM上体现出来</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(box);</span><br><span class="line"><span class="keyword">var</span> nodes = box.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = nodeList.length; i &lt; len; i++) &#123;</span><br><span class="line">		arr.push(nodeList[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNodeList = makeArray(nodes);</span><br><span class="line">newNodeList.push(<span class="string">"&lt;li&gt;动态添加的节点四&lt;/li&gt;"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newNodeList);  <span class="comment">// (10) [text, li, text, li, text, li, text, li, text, "&lt;li&gt;动态添加的节点四&lt;/li&gt;"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 Array对象的prototype属性的slice方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(nodeList);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是第二种方法在一些IE8及以下浏览器上会有问题， 会在浏览器上显示“缺少 JScript 对象”</span></span><br><span class="line"><span class="comment">// 两种方法都想使用的 兼容写法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">nodeList</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(nodeList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = nodeList.length; i &lt; len; i++) &#123;</span><br><span class="line">            arr.push(nodeList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HTMLCollection"><a href="#HTMLCollection" class="headerlink" title="HTMLCollection"></a>HTMLCollection</h4><p>表示HTML元素的集合，同样拥有length属性，类数组对象</p>
<p>常见的返回 HTMLCollection对象的操作</p>
<ul>
<li>Ele.getElementByTagName()，会根据元素名称返回元素的集合。</li>
<li>document.scripts，会返回页面里的全部script的集合</li>
<li>document.links 属性，返回页面所有a元素</li>
<li>document.images 属性，返回页面中所有的image 标签元素集合</li>
<li>document.forms 属性，返回页面中所有form表单</li>
<li>tr.cells ，返回这个tr元素的所有td子元素的集合</li>
<li>select.options，返回这个select的所有选项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTMLCollection</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.scripts;</span><br><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.links;</span><br><span class="line"><span class="keyword">var</span> cells = <span class="built_in">document</span>.getElementById(<span class="string">"tr"</span>).cells;</span><br><span class="line"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.images;</span><br><span class="line"><span class="keyword">var</span> forms = <span class="built_in">document</span>.forms;</span><br><span class="line"><span class="keyword">var</span> options = <span class="built_in">document</span>.getElementById(<span class="string">"select"</span>).options;</span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(script);  <span class="comment">// HTMLCollection [script]</span></span><br><span class="line"><span class="built_in">console</span>.log(links);  <span class="comment">// HTMLCollection(2) [a, a]</span></span><br><span class="line"><span class="built_in">console</span>.log(cells);  <span class="comment">// HTMLCollection(3) [td, td, td]</span></span><br><span class="line"><span class="built_in">console</span>.log(imgs);  <span class="comment">// HTMLCollection(2) [img, img]</span></span><br><span class="line"><span class="built_in">console</span>.log(forms);  <span class="comment">// HTMLCollection(2) [form, form]</span></span><br><span class="line"><span class="built_in">console</span>.log(options);  <span class="comment">// HTMLOptionsCollection(3) [option, option, option, selectedIndex: 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(ps);  <span class="comment">// HTMLCollection [p]</span></span><br></pre></td></tr></table></figure>

<h4 id="NamedNodeMap"><a href="#NamedNodeMap" class="headerlink" title="NamedNodeMap"></a>NamedNodeMap</h4><p>通过访问元素节点的 attributes 属性得到</p>
<p><code>Ele.attributes</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line"><span class="keyword">var</span> attrs = box.attributes;</span><br><span class="line"><span class="built_in">console</span>.log(attrs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NamedNodeMap &#123;0: id, id: id, length: 1&#125;</span></span><br><span class="line"><span class="comment">// 0: id</span></span><br><span class="line"><span class="comment">// length: 1</span></span><br><span class="line"><span class="comment">// id: id</span></span><br><span class="line"><span class="comment">// __proto__: NamedNodeMap</span></span><br></pre></td></tr></table></figure>

<h4 id="类数组对象的动态属性"><a href="#类数组对象的动态属性" class="headerlink" title="类数组对象的动态属性"></a>类数组对象的动态属性</h4><p>NodeList，HTMLCollection，NamedNodeMap 三个集合都是动态的、有生命的 对象</p>
<p>它们是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反应到这些对象中</p>
<p>每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; divs.length)&#123;  <span class="comment">// 注意这里，由于HTMLCollection的动态特性，divs的length属性是一直改变的，所以在每次循环的时候都会重新判断length，会进入死循环</span></span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>));</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只需要拿一个变量保存一下length即可解决</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> length = divs.length;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; length)&#123;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">"div"</span>));</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/01/10/JavaScript/image-20200530171729322.png" alt="image-20200530171729322"></p>
<p>前三个方法会在IE6~8 中也可以使用</p>
<h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><p><code>document.getElementById(&quot;muDiv&quot;);</code></p>
<p>当出现不同元素ID和NAME值相同的时候，在IE7中使用的时候会有BUG</p>
<p>修复思路：</p>
<p>在取得元素后，先判断是根据name还是id来取得的，如果不是，就把拿到所有符合条件的节点，挨个判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getElementById = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">	<span class="comment">// 针对ie浏览器修复</span></span><br><span class="line">	<span class="keyword">if</span>(!+<span class="string">"\v1"</span>) &#123;  <span class="comment">// 利用了各个浏览器对转义字符 \v 的解释，ie中\v没有转义，得到的字符就是v，其他浏览器是类似空格的符号</span></span><br><span class="line">		<span class="keyword">if</span>(el &amp;&amp; el.id === id)&#123;</span><br><span class="line">			<span class="keyword">return</span> el;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 获得所有id或name值符合条件的，然后逐个判断</span></span><br><span class="line">			<span class="keyword">var</span> els = <span class="built_in">document</span>.all[id],</span><br><span class="line">			n = els.length;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(els[i].id === id) &#123;</span><br><span class="line">					<span class="keyword">return</span> els[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> el;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h3><p>返回一个对象的集合</p>
<p><code>document.getElementsByName(&quot;myUl&quot;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> yUl = <span class="built_in">document</span>.getElementsByName(<span class="string">"myUl"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myUl);  <span class="comment">// 返回一个集合，NodeList</span></span><br></pre></td></tr></table></figure>

<h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h3><p><code>var list1 = document.getElementsByTagName(&quot;li&quot;);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>);   <span class="comment">// 传入不区分大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(list1.length);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myUl"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"light"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dark"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"light"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"myUl"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 就可以同时获得两个节点，返回的是HTMLCollection，类数组</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> list1 = ul.getElemenetsByClassName(<span class="string">'light'</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 传入多个类名的时候，就可以空格隔开，不分前后</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：这个方法在旧式浏览器中不支持，下面就写一下兼容性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>

<h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h3><p>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。</p>
<p><strong>注意：</strong> querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"><span class="keyword">var</span> ul = myDiv.querySelector(<span class="string">"#myUl"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ul);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'li:last-child'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'span'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.foo'</span>));</span><br><span class="line"><span class="comment">// 试图获取一个不存在的节点时，会返回null</span></span><br></pre></td></tr></table></figure>

<h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myDiv.querySelectorAll(<span class="string">'ul'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试图获取不存在的节点时，会返回 []</span></span><br><span class="line"><span class="comment">// 但是，类数组对象具有动态性，querySelectorAll() 返回的不是纯粹的NodeList，而是类似的 StaticNodeList</span></span><br></pre></td></tr></table></figure>

<h2 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h2><p><img src="/2019/01/10/JavaScript/image-20200530171744153.png" alt="image-20200530171744153"></p>
<h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h4><p>用于向 NodeList列表添加节点，返回新增的节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myUl = <span class="built_in">document</span>.getElementById(<span class="string">"myUl"</span>);</span><br><span class="line"><span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(<span class="string">"4"</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"></span><br><span class="line">li.appendChild(txt);</span><br><span class="line">myUl.appendChild(li);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：如果是把已有的节点appendChild到其他节点，那么会做 移动处理，不会复制</span></span><br><span class="line"><span class="keyword">var</span> firstLi = <span class="built_in">document</span>.getElementById(<span class="string">'tr'</span>).firstElementChild;</span><br><span class="line">myUl.appendChild(firstLi);</span><br></pre></td></tr></table></figure>

<h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h4><p>在指定的已有子节点之前插入新的子节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> liNew = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">liNew.appendChild(txt);</span><br><span class="line"><span class="keyword">var</span> li2 = myUl.children.item(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 接收两个参数，第一个是要插入的节点，第二个是参照节点，会在参照节点前面插入</span></span><br><span class="line">myUl.insertBefore(liNew, li2);</span><br><span class="line"><span class="comment">// 插到第一位，也就是第一个节点的前面</span></span><br><span class="line">myUl.insertBefore(liNew, myUl.firstElementChild);</span><br></pre></td></tr></table></figure>

<h4 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode()"></a>cloneNode()</h4><p>创建节点的拷贝，并返回该副本</p>
<p>拷贝的节点要有父节点才能看到，如果没有父节点，要通过appendChild()、insertBefore()、replaceChild() 等方法对其进行添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myUl = <span class="built_in">document</span>.getElementById(<span class="string">"myUl"</span>);</span><br><span class="line"><span class="keyword">var</span> newNode = myUl.cloneNode(); <span class="comment">// 这样的话只会克隆父节点，没有子节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newNode = myUl.cloneNode(<span class="literal">true</span>);  <span class="comment">// 这样才会连同子节点，深复制</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newNode); </span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(newNode);  <span class="comment">// 添加才会显示</span></span><br></pre></td></tr></table></figure>

<h4 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h4><p>合并相邻的节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"DOM探索"</span>);</span><br><span class="line">div.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode2 = <span class="built_in">document</span>.createTextNode(<span class="string">"之节点操作"</span>);</span><br><span class="line">div.appendChild(textNode2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(div.childNodes.length);  <span class="comment">// 2</span></span><br><span class="line">div.normalize();</span><br><span class="line"><span class="built_in">console</span>.log(div.childNodes.length);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h4><p>按指定的位置把文本节点分割成两个节点</p>
<p>和normalize反过来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = div.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 就分割成了两个节点</span></span><br></pre></td></tr></table></figure>

<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p><img src="/2019/01/10/JavaScript/image-20200530171757962.png" alt="image-20200530171757962"></p>
<h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild()"></a>removeChild()</h3><p>删除子节点，返回被删除的子节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myUl = <span class="built_in">document</span>.getElementById(<span class="string">"myUl"</span>);</span><br><span class="line"><span class="keyword">var</span> secondChild = myUl.removeChild(myUl.childNodes[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h3><p>ie的私有实现</p>
<p>将目标节点从文档中删除，返回目标节点</p>
<p>参数是布尔值，默认值是false</p>
<p>用的不多</p>
<h3 id="innerHTML-1"><a href="#innerHTML-1" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>读写属性</p>
<p>与removeChild()比较：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div.parentNode);  <span class="comment">// ie及其他都为null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.body.appendChild(div));</span><br><span class="line"><span class="comment">// ie6-8会返回文档碎片对象，是为了让我们重复使用，其他为null</span></span><br><span class="line"><span class="built_in">console</span>.log(div.parentNode);</span><br><span class="line"><span class="built_in">console</span>.log(div.parentNode.nodeType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myDiv.parentNode);  <span class="comment">// null 所有的浏览器都是</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有浏览器都显示正常，可以得到子节点</span></span><br><span class="line">myDiv.parentNode.removeChild(myDiv);</span><br><span class="line"><span class="built_in">console</span>.log(myDiv.id + <span class="string">":"</span> + myDiv.innerHTML);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ie上，就被清空得不到了</span></span><br><span class="line">myDiv.parentNode.innerHTML = <span class="string">""</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myDiv.id + <span class="string">":"</span> + myDiv.innerHTML);</span><br></pre></td></tr></table></figure>

<h4 id="总结："><a href="#总结：" class="headerlink" title="// 总结："></a>// 总结：</h4><p>在ie6-8下，removeChild()相当于是掰断了树枝，但是树枝还可以再次使用，innerHTML就是把树枝烧掉了</p>
<p>chrome中，removeChild() 和 innerHTML 都是掰断树枝，可以再次使用。</p>
<h1 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h1><p>什么是事件？ js与HTML的交互就是通过事件实现的</p>
<p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。</p>
<p>主要学习两种绑定事件的方式：HTML事件、DOM 0级事件</p>
<h2 id="HTML事件"><a href="#HTML事件" class="headerlink" title="HTML事件"></a>HTML事件</h2><p>直接在HTML元素标签内添加事件，执行脚本。</p>
<p>语法：</p>
<p><code>&lt;tag 事件=&quot;执行脚本&quot;&gt;&lt;/tag&gt;</code></p>
<p>功能：</p>
<p>在HTML元素上绑定时间</p>
<p>说明：</p>
<p>执行脚本可以使一个函数的调用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"弹出"</span> <span class="attr">onclick</span>=<span class="string">"alert("</span>我是按钮")"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 鼠标滑过时调用mouseoverFn函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">onmouseover</span>=<span class="string">"mouseoverFn(this)"</span> <span class="attr">onmouseout</span>=<span class="string">"mouseoutFn(this)"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">mouseoverFn</span><span class="params">(btn)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// this 指向</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(btn);  <span class="comment">// 就是调用的div的引用</span></span></span><br><span class="line"><span class="actionscript">        btn.style.background=<span class="string">"#f00"</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">mouseoutFn</span><span class="params">(btn)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        btn.style.background=<span class="string">"#00f"</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在事件触发的函数里，this是对该DOM对象的引用</p>
<h2 id="DOM-0级事件"><a href="#DOM-0级事件" class="headerlink" title="DOM 0级事件"></a>DOM 0级事件</h2><p>通过DOM获取HTML元素</p>
<p>（获取HTML元素）.事件 = 执行脚本</p>
<p>语法：</p>
<p>ele.事件 = 执行脚本</p>
<p>功能：</p>
<p>在DOM对象上绑定事件</p>
<p>说明：</p>
<p>执行脚本可以是一个匿名函数，也可以是一个函数的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取按钮</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"><span class="comment">// 给按钮绑定事件 ， 在点击时执行匿名函数</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// 指向该DOM元素</span></span><br><span class="line">    <span class="keyword">this</span>.className = <span class="string">"unlock"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>不推荐使用HTML事件的原因</p>
<ol>
<li>多元素绑定相同事件时，效率低。</li>
<li>不建议在HTML元素中写JS代码，应该分开写。</li>
</ol>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><h3 id="onfocus-onblur"><a href="#onfocus-onblur" class="headerlink" title="onfocus() onblur()"></a>onfocus() onblur()</h3><p>只能用于</p>
<ul>
<li>input 标签 type为text、password</li>
<li>textarea标签</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phone = <span class="built_in">document</span>.getElementById(<span class="string">"phone"</span>);</span><br><span class="line"><span class="keyword">var</span> tip = <span class="built_in">document</span>.getElementById(<span class="string">"tip"</span>);</span><br><span class="line"><span class="comment">// 给文本框绑定激活的事件</span></span><br><span class="line">phone.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//让tip显示出来</span></span><br><span class="line">    tip.style.display = <span class="string">"block"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文本框失去焦点的事件</span></span><br><span class="line">phone.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> phoneVal = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span>(phoneVal.length == <span class="number">11</span> &amp;&amp; <span class="built_in">isNaN</span>(phoneVal)==flase) &#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onchange"><a href="#onchange" class="headerlink" title="onchange()"></a>onchange()</h3><p>页面加载时触发</p>
<p>如果把script 标签放在body标签前面的话，就会在加载DOM元素前加载脚本，会获取不到DOM节点。</p>
<p>就可以让window加载完毕后再执行脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 脚本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onchange-1"><a href="#onchange-1" class="headerlink" title="onchange()"></a>onchange()</h3><p>域的内容改变时触发，一般用于select标签、checkbox、radio</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">"menu"</span>);</span><br><span class="line">menu.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> bgcolor = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="comment">// var bgcolor = menu.options[menu.selectedIndex].value;</span></span><br><span class="line">    <span class="keyword">if</span>(bgcolor == <span class="string">""</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.body.style.background = <span class="string">"#fff"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.style.background = bgcolor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onsubmit"><a href="#onsubmit" class="headerlink" title="onsubmit()"></a>onsubmit()</h3><p>表单中的确认按钮被点击时触发 </p>
<p>但是此事件不是加在按钮上，而是加在表单上的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</span><br><span class="line">box.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我被按下了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">box.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我被移动了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">box.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我被松开了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onresize"><a href="#onresize" class="headerlink" title="onresize()"></a>onresize()</h3><p>作用于window对象，当调整浏览器窗口的大小时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"尺寸改变了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onscroll"><a href="#onscroll" class="headerlink" title="onscroll()"></a>onscroll()</h3><p>拖动滚动条滚动时触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我被拖动了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><h3 id="onkeydown"><a href="#onkeydown" class="headerlink" title="onkeydown()"></a>onkeydown()</h3><p>在用户按下一个键盘按键时触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeydown=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// event代表事件的状态，如触发event对象的元素、鼠标的位置及状态等</span></span><br><span class="line">    <span class="comment">// 在事件触发的function里，用一个参数接收事件对象</span></span><br><span class="line">    <span class="comment">// keyCode属性就作用在event对象上</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.keyCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onkeypress、onkeyup 两个方法和onkeydown同理。</p>
<h1 id="JS事件"><a href="#JS事件" class="headerlink" title="JS事件"></a>JS事件</h1><p>事件是可以被JavaScript侦测到的行为，通俗说就是 当用户与Web页面进行某些交互时，解释器就会创建相应的event对象以描述事件信息。</p>
<p>常见的事件：</p>
<p>用户点击</p>
<p>鼠标经过</p>
<p>按下键盘</p>
<p>滚动窗口或者窗口大小改变</p>
<p>页面元素加载完成或者加载失败</p>
<h2 id="事件句柄"><a href="#事件句柄" class="headerlink" title="事件句柄"></a>事件句柄</h2><p>事件句柄（又称事件处理函数、事件监听函数），指用于相应某个事件而调用的函数。每一个事件均对应一个事件句柄，在程序执行时，将相应的函数或语句指定给事件句柄，则在该事件发生时，浏览器便会执行指定的函数或语句。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><h3 id="事件定义-添加"><a href="#事件定义-添加" class="headerlink" title="事件定义/添加"></a>事件定义/添加</h3><p>为特定事件定义监听函数有三种方式</p>
<h4 id="直接在HTML中定义"><a href="#直接在HTML中定义" class="headerlink" title="直接在HTML中定义"></a>直接在HTML中定义</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('hello')"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是违反了“内容与行为分离”的原则，应尽可能避免使用。</p>
<h4 id="DOM-0级事件-1"><a href="#DOM-0级事件-1" class="headerlink" title="DOM 0级事件"></a>DOM 0级事件</h4><p>前面有笔记，缺点是 元素只能绑定一个监听函数。</p>
<h4 id="DOM-2级事件"><a href="#DOM-2级事件" class="headerlink" title="DOM 2级事件"></a>DOM 2级事件</h4><p>高级事件处理方式，一个事件可以绑定多个监听函数。</p>
<p><code>ele.addEventListener(&quot;click&quot;, function(){}, false);</code> // DOM</p>
<p><code>ele.attachEvent(&quot;onclick&quot;, function(){});</code>  // IE</p>
<p>此语法可以为一个元素绑定多个监听函数，但需要注意浏览器兼容性问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"><span class="comment">// 三个参数  1.绑定的事件类型  2.事件句柄  3.默认false，管理事件冒泡或者捕获</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>DOM2级支持同一dom元素注册多个同种事件</p>
<p>DOM2级新增了捕获和冒泡的概念</p>
<h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><p><code>removeEventListener()</code></p>
<p>语法：<code>element.removeEventListener(event, function,useCapture)</code></p>
<p>功能： 移除addEventListener()方法添加的事件句柄。</p>
<p>参数：</p>
<ul>
<li>event：必须。字符串，要移除的事件名称</li>
<li>function：必须。指定要移除的函数</li>
<li>useCapture：可选。布尔值，指定移除事件句柄的阶段。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.removeEventListener(<span class="string">"click"</span>, func2);</span><br></pre></td></tr></table></figure>

<h2 id="IE事件流（IE事件处理程序）"><a href="#IE事件流（IE事件处理程序）" class="headerlink" title="IE事件流（IE事件处理程序）"></a>IE事件流（IE事件处理程序）</h2><p>针对IE8及以下做的兼容</p>
<h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h3><p><code>attachEvent()</code></p>
<p>语法：<code>element.attchEvent(event, function)</code></p>
<p>功能：用于向指定元素添加事件句柄</p>
<p>参数：  // ie不支持事件捕获，默认就是冒泡，所以没有第三个参数</p>
<p>event：必须。字符串，指定事件名，必须加“on”前缀。</p>
<p>function：必须。指定事件触发时执行的函数。</p>
<h3 id="移除事件-1"><a href="#移除事件-1" class="headerlink" title="移除事件"></a>移除事件</h3><p><code>detachEvent()</code></p>
<p>语法：<code>element.detachEvent(event, function)</code></p>
<p>功能：移除attachEvent()方法添加的事件句柄。</p>
<p>参数：<br>event：必须。字符串，要移除的事件名称。</p>
<p>function：必须，指定要移除的函数。</p>
<h2 id="事件冒泡、事件捕获"><a href="#事件冒泡、事件捕获" class="headerlink" title="事件冒泡、事件捕获"></a>事件冒泡、事件捕获</h2><p>最初是 微软和网景 在浏览器中的竞争，后来就两个都支持了。</p>
<h3 id="事件周期"><a href="#事件周期" class="headerlink" title="事件周期"></a>事件周期</h3><p>解释器创建一个event对象后，会按如下过程将其在HTML元素间进行传播</p>
<p>第一阶段：事件捕获，事件对象沿DOM树向下传播</p>
<p>第二阶段：目标触发，运行事件监听函数</p>
<p>第三阶段：事件冒泡，事件沿DOM树向上传播</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// 事件冒泡</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"parent事件被触发,"</span> + <span class="keyword">this</span>.id);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"child"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"child事件被触发，"</span> + <span class="keyword">this</span>.id);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    <span class="comment">// 父 添加事件</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 子 添加事件</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 点击的效果： 先触发 子 事件，再触发 父 事件。</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在直系亲属树结构中，点击某个元素，由于冒泡作用，亲属树上的元素，凡是添加了事件的，都会被触发。</p>
<p>大部分情况下使用的就是 事件冒泡。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>和事件冒泡正好反过来，从上往下找。</p>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>原理 就是事件冒泡。</p>
<p>也就是说，我自己的事件没有绑定到我自己身上，而是委托给了父元素或其他元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证了只添加一次事件，把本来要绑定到li上的事件绑定到了ul上</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">ul.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(event.target.id == <span class="string">"one"</span>)&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="event对象常用属性和方法"><a href="#event对象常用属性和方法" class="headerlink" title="event对象常用属性和方法"></a>event对象常用属性和方法</h2><p>在事件句柄中，有一个参数event。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>事件的类型，如：click。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同一个元素触发不同的事件</span></span><br><span class="line"><span class="keyword">var</span> eventFUn = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.type == <span class="string">"click"</span>)&#123;</span><br><span class="line">        alert(<span class="string">"click事件被触发"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(event.type == <span class="string">"mouseout"</span>)&#123;</span><br><span class="line">        alert(<span class="string">"mouseout事件被触发"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="target、currentTarget"><a href="#target、currentTarget" class="headerlink" title="target、currentTarget"></a>target、currentTarget</h3><p>事件源，就是发生事件的元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>);</span><br><span class="line">parent.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点击儿子，事件在父亲上面</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.target);  <span class="comment">// target是儿子对象，事件源对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.currentTarget);  <span class="comment">// currentTarget 事件绑定在谁身上就指向谁</span></span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="preventDefault"><a href="#preventDefault" class="headerlink" title="preventDefault"></a>preventDefault</h3><p>阻止默认行为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"a"</span>);</span><br><span class="line">a.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">11</span>);  <span class="comment">// 如果不去阻止默认行为的话，会先弹框，然后a标签还是会跳转，也就是a标签的默认行为还是会发生</span></span><br><span class="line">    event.preventDefault();  <span class="comment">// 加上这个函数以后，就会阻止a标签的默认行为，就不会跳转了 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation"></a>stopPropagation</h3><p>阻止元素的冒泡或捕获</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">"parent"</span>);</span><br><span class="line">parent.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"parent"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">child.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"child"</span>);</span><br><span class="line">    event.stopPropagation();  <span class="comment">// 当执行完child后，冒泡被阻止，parent就不会再触发了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="clientY、pageY、screenY"><a href="#clientY、pageY、screenY" class="headerlink" title="clientY、pageY、screenY"></a>clientY、pageY、screenY</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gaodu = <span class="built_in">document</span>.getElementById(<span class="string">"gaodu"</span>);</span><br><span class="line">gaodu.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.clientY+event.pageY+event.screenY);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>clientY</p>
<p>从浏览器顶部底边开始，到鼠标点击的位置的Y值，<strong>不计算滚动条</strong>已经滚动了的位置。</p>
</li>
<li><p>pageY</p>
<p>从浏览器顶部底边开始，到鼠标点击的位置的Y值，<strong>计算滚动条</strong>已经滚动了的位置。</p>
</li>
<li><p>screenY</p>
<p>屏幕的最顶部到鼠标位置，不管浏览器的位置在哪</p>
</li>
</ul>
<h3 id="IE8中的event对象-attachEvent"><a href="#IE8中的event对象-attachEvent" class="headerlink" title="IE8中的event对象  attachEvent"></a>IE8中的event对象  attachEvent</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mybtn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line">mybtn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type);  <span class="comment">// 时间类型</span></span><br><span class="line">    event.returnValue = <span class="literal">false</span>;  <span class="comment">// 阻止默认行为，同preventDefault；</span></span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;  <span class="comment">// 阻止事件冒泡，同stopPropagation;</span></span><br><span class="line">    event.srcElement;  <span class="comment">// 同target</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI类型"><a href="#UI类型" class="headerlink" title="UI类型"></a>UI类型</h3><h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><p>当页面完全加载后在window对象上面触发</p>
<p>可以应用于image标签上实现图片预加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image();  <span class="comment">// 这样可以把图片存在内存中</span></span><br><span class="line">image.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Image loaded."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">image.src = <span class="string">"smile.gif"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h4><p>用户从一个页面切换到另一个页面</p>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>窗口大小发生变化时触发，重复触发， 也就很损耗性能。</p>
<h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p>窗口滚动事件，重复触发，也就很损耗性能。</p>
<h4 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h4><p>元素失去焦点时触发</p>
<h4 id="focus"><a href="#focus" class="headerlink" title="focus"></a>focus</h4><p>元素获取焦点的时候触发，不支持冒泡</p>
<h4 id="focusin"><a href="#focusin" class="headerlink" title="focusin"></a>focusin</h4><p>元素获取焦点时触发，支持冒泡，浏览器支持 IE5.5+，Safari5.1+，chrome等</p>
<h4 id="focusout"><a href="#focusout" class="headerlink" title="focusout"></a>focusout</h4><p>同blur，浏览器支持 IE5.5+，Safari5.1+，chrome等</p>
<h3 id="鼠标事件-1"><a href="#鼠标事件-1" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><h4 id="click"><a href="#click" class="headerlink" title="click"></a>click</h4><p>鼠标点击事件</p>
<h4 id="dbclick"><a href="#dbclick" class="headerlink" title="dbclick"></a>dbclick</h4><p>鼠标双击事件</p>
<h4 id="mousedown"><a href="#mousedown" class="headerlink" title="mousedown"></a>mousedown</h4><p>鼠标按下的时候触发</p>
<h4 id="mouseup"><a href="#mouseup" class="headerlink" title="mouseup"></a>mouseup</h4><p>松开鼠标触发</p>
<h4 id="mousemove"><a href="#mousemove" class="headerlink" title="mousemove"></a>mousemove</h4><p>鼠标移动的时候触发，重复事件</p>
<h4 id="mouseout"><a href="#mouseout" class="headerlink" title="mouseout"></a>mouseout</h4><p>鼠标离开元素 或者 其子元素的时候触发</p>
<h4 id="mouseover"><a href="#mouseover" class="headerlink" title="mouseover"></a>mouseover</h4><p>鼠标从元素外部进入元素 或者 其子元素的时候触发</p>
<h4 id="mouseenter"><a href="#mouseenter" class="headerlink" title="mouseenter"></a>mouseenter</h4><p>鼠标进入目标元素触发，只能进入目标元素时才触发</p>
<h4 id="mouseleave"><a href="#mouseleave" class="headerlink" title="mouseleave"></a>mouseleave</h4><p>鼠标指针离开被选元素时触发，只能进入目标元素时才触发</p>
<h3 id="键盘事件-1"><a href="#键盘事件-1" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="keydown"><a href="#keydown" class="headerlink" title="keydown"></a>keydown</h4><p>键码，敲击任意键触发</p>
<h4 id="keyup"><a href="#keyup" class="headerlink" title="keyup"></a>keyup</h4><p>键盘抬起的时候触发，也就是释放某键的时候触发</p>
<h4 id="keypress"><a href="#keypress" class="headerlink" title="keypress"></a>keypress</h4><p>按下 <strong>字符键</strong> 触发，对其他键位的支持有有限</p>
<h4 id="textInput"><a href="#textInput" class="headerlink" title="textInput"></a>textInput</h4><p>输入什么，event.data 的值就是什么</p>
<h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><h4 id="DOMNodeRemoved"><a href="#DOMNodeRemoved" class="headerlink" title="DOMNodeRemoved"></a>DOMNodeRemoved</h4><p><code>ele.addEventListener(&quot;DOMNodeRemoved&quot;, function(){});</code></p>
<p>在 节点内有节点被删除的时候触发。</p>
<h4 id="DOMNodeRemovedFromDocument"><a href="#DOMNodeRemovedFromDocument" class="headerlink" title="DOMNodeRemovedFromDocument"></a>DOMNodeRemovedFromDocument</h4><p>在节点被移除之前 触发</p>
<h4 id="DOMNodeInserted"><a href="#DOMNodeInserted" class="headerlink" title="DOMNodeInserted"></a>DOMNodeInserted</h4><p>有元素被添加时触发</p>
<h4 id="DOMSubtreeModified"><a href="#DOMSubtreeModified" class="headerlink" title="DOMSubtreeModified"></a>DOMSubtreeModified</h4><p>DOM结构中发生任何变化都会触发</p>
<h4 id="DOMNodeInsertedIntoDocument"><a href="#DOMNodeInsertedIntoDocument" class="headerlink" title="DOMNodeInsertedIntoDocument"></a>DOMNodeInsertedIntoDocument</h4><p> 从文档中添加之前被触发</p>
<h3 id="HTML5-新增事件"><a href="#HTML5-新增事件" class="headerlink" title="HTML5 新增事件"></a>HTML5 新增事件</h3><h4 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h4><p>只要DOM树完成加载就会触发，不管其他image、js、css和其他资源，肯定要比load事件快。</p>
<h4 id="readystatechange"><a href="#readystatechange" class="headerlink" title="readystatechange"></a>readystatechange</h4><p>支持ie、Firefox、Opera，有限制。难预料，不推荐使用，可能比load慢。</p>
<h4 id="hashchange"><a href="#hashchange" class="headerlink" title="hashchange"></a>hashchange</h4><p>只能给window对象添加，#号后面的值发生变化的时候触发</p>
<p>此时的event对象里会有两个属性：oldURL、newURL</p>
<p>记录地址栏状态的场景使用</p>
<h3 id="常用事件类型"><a href="#常用事件类型" class="headerlink" title="常用事件类型"></a>常用事件类型</h3><h4 id="touchstart"><a href="#touchstart" class="headerlink" title="touchstart"></a>touchstart</h4><p>手指触摸屏幕 时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mybtn = <span class="built_in">document</span>.getElementById(<span class="string">"mybtn"</span>);</span><br><span class="line"><span class="comment">// 手指触摸屏幕时触发</span></span><br><span class="line">mybtn.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(event.touches);  <span class="comment">// 当前触摸屏幕的触摸点数组，也就是记录触摸点的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(event.changedTouches);  <span class="comment">// 记录触摸并移动的手指头的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(event.targetTouches);  <span class="comment">// 在事件对象上面的触摸点的信息</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="touchmove"><a href="#touchmove" class="headerlink" title="touchmove"></a>touchmove</h4><p>手指在屏幕上滑动的时候触发，重复触发</p>
<h4 id="touchend"><a href="#touchend" class="headerlink" title="touchend"></a>touchend</h4><p>手指从屏幕上移开时触发</p>
<h4 id="touchcancel"><a href="#touchcancel" class="headerlink" title="touchcancel"></a>touchcancel</h4><p>当系统停止跟踪触摸时触发</p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM(browser object model)浏览器对象模型</p>
<p>BOM提供了很多的对象，用于访问浏览器的功能。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>window是浏览器的一个实例，在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</p>
<p>也就意味着我们在网页中定义的任何一个对象、变量、函数 都是以window作为global对象，因此我们才有权限访问它的方法等等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">15</span>;  <span class="comment">// 这条语句相当于是 window.age = 15;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"我"</span> + age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个全局变量</span></span><br><span class="line"><span class="built_in">window</span>.username = <span class="string">"marry"</span>;  <span class="comment">// 相当于 var username = "marry";</span></span><br><span class="line"><span class="comment">// 声明一个全局方法</span></span><br><span class="line"><span class="built_in">window</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"我是"</span>+<span class="keyword">this</span>.username);  <span class="comment">// 甚至alert方法也是window对象的</span></span><br><span class="line">&#125;</span><br><span class="line">sayAge();</span><br><span class="line"><span class="built_in">window</span>.sayName();  <span class="comment">// sayName();同等</span></span><br></pre></td></tr></table></figure>

<h3 id="window对象的方法"><a href="#window对象的方法" class="headerlink" title="window对象的方法"></a>window对象的方法</h3><h4 id="window-alert"><a href="#window-alert" class="headerlink" title="window.alert()"></a>window.alert()</h4><p>显示带有一段消息和一个确认按钮的警告框。</p>
<h4 id="window-confirm-“message”"><a href="#window-confirm-“message”" class="headerlink" title="window.confirm(“message”)"></a>window.confirm(“message”)</h4><p>显示一个带有指定消息和OK及取消按钮的对话框。</p>
<p>返回值：</p>
<p>如果用户点击确定按钮，则confirm()返回true</p>
<p>如果用户点击取消按钮，则confirm()返回false</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"info"</span>&gt;</span>我是信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"删除"</span> <span class="attr">id</span>=<span class="string">"del"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.getElementById(<span class="string">"del"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">if</span> (<span class="built_in">window</span>.confirm(<span class="string">"确定要删除吗？"</span>))&#123;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">"info"</span>));</span></span><br><span class="line"><span class="actionscript">		&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">return</span> <span class="literal">null</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)	</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="window-prompt-“text”-“defaultText”"><a href="#window-prompt-“text”-“defaultText”" class="headerlink" title="window.prompt(“text”, “defaultText”)"></a>window.prompt(“text”, “defaultText”)</h4><p>参数：</p>
<p>text： 要在对话框中显示的纯文本，而不是HTML格式的文本</p>
<p>defaultText：默认的输入文本</p>
<p>返回值：</p>
<p>如果用户单击取消，返回null</p>
<p>如果用户点击确认，返回输入字段当前显示的文字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"prompt"</span>&gt;</span>prompt测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> prom = <span class="built_in">document</span>.getElementById(<span class="string">"prompt"</span>);</span></span><br><span class="line"><span class="actionscript">	prom.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> textInfo = <span class="built_in">window</span>.prompt(<span class="string">"我是提示信息"</span>, <span class="string">"我是默认输入的信息"</span>);</span></span><br><span class="line">		if(textInfo)&#123;</span><br><span class="line">			alert(textInfo);</span><br><span class="line"><span class="actionscript">		&#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line">			alert(textInfo);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="window-open-pageURL-name-parameters"><a href="#window-open-pageURL-name-parameters" class="headerlink" title="window.open(pageURL, name, parameters)"></a>window.open(pageURL, name, parameters)</h4><p>打开一个新的浏览器窗口或查找一个已命名的窗口</p>
<p>参数：</p>
<ul>
<li><p>pageURL：子窗口的路径</p>
</li>
<li><p>name：子窗口的句柄，方便后期通过name对子窗口进行引用</p>
</li>
<li><p>parameters：窗口参数，各参数用逗号分隔。</p>
<ul>
<li>width：窗口宽度</li>
<li>height：窗口高度</li>
<li>left：窗口X轴坐标</li>
<li>top：窗口Y坐标</li>
<li>toolbar：是否显示浏览器工具栏</li>
<li>menubar：是否显示菜单栏</li>
<li>scrollbars：是否显示滚动条</li>
<li>location：是否显示地址栏字段</li>
<li>status：是否添加状态栏</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- open --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"open"</span>&gt;</span>打开新窗口<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="built_in">document</span>.getElementById(<span class="string">"open"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.open(<span class="string">'DOM.html'</span>, <span class="string">'name'</span>, <span class="string">'width=400, height=200, left=0, top=0, toolbar=no, menubar=no, scrollbars=no, location=no,status=no'</span>);</span></span><br><span class="line">	&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="window-close"><a href="#window-close" class="headerlink" title="window.close()"></a>window.close()</h4><p>关闭此窗口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">window</span>.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="window-innerWidth-innerHeight"><a href="#window-innerWidth-innerHeight" class="headerlink" title="window.innerWidth/ innerHeight"></a>window.innerWidth/ innerHeight</h4><p>属于window对象的属性，获取浏览器可视区域的宽度和高度</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>JavaScript是单线程语言，单线程就是所执行的代码必须按照顺序执行。</p>
<p>但是允许设置超时值和间歇时间值来调度代码在特定的时刻执行。</p>
<h4 id="超时调用"><a href="#超时调用" class="headerlink" title="超时调用"></a>超时调用</h4><p><code>setTimeout(code, millisec);</code> </p>
<p>在指定的毫秒数后调用函数或计算表达式。</p>
<p>参数：</p>
<ol>
<li>code：要调用的函数或要执行的js代码</li>
<li>millisec：在执行代码前需要等待的毫秒数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeout1 = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"延迟了1s"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 取消了超时调用</span></span><br><span class="line">clearTimeout(timeout1);</span><br></pre></td></tr></table></figure>

<p>在调用setTimeout方法后，会返回一个ID值，表示超时调用，可以通过它来取消超时调用。</p>
<p><code>clearTimeout(timeout1);</code></p>
<h4 id="间歇调用"><a href="#间歇调用" class="headerlink" title="间歇调用"></a>间歇调用</h4><p><code>setInterval(code, millisec)</code></p>
<p>每隔指定的时间执行一次代码</p>
<p>参数：</p>
<ol>
<li>code：要调用的函数或要执行的js代码</li>
<li>millisec：周期性执行或调用code之间的时间间隔，以毫秒计</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeout1 = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"延迟了1s"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(timeout1);</span><br><span class="line"><span class="built_in">window</span>.num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">window</span>.setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"你好"</span>);</span><br><span class="line">	<span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(num);</span><br><span class="line">	<span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line">	div.appendChild(txt);</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">	num++;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>取消间歇调用：</p>
<p><code>clearInterval()</code></p>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>location对象提供了与当前窗口中加载的文档有关的信息，还提供了一些导航的功能，它既是window对象的属性，也是document对象的属性。</p>
<h4 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h4><p><code>location.href</code></p>
<p>返回当前加载页面的完整URL</p>
<p>location.href与window.location.href等价</p>
<p>可以获取也可以设置</p>
<p><code>location.href = xx</code></p>
<h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h4><p><code>location.hash</code></p>
<p>返回URL中的hash（#号后跟零或多个字符），如果不包含则返回空字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    location.hash = <span class="string">"#top"</span>;  <span class="comment">// 也可以设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="location-host"><a href="#location-host" class="headerlink" title="location.host"></a>location.host</h4><p>返回服务器名称和端口号（如果有）</p>
<p><code>console.log(location.host);</code> </p>
<h4 id="location-pathname"><a href="#location-pathname" class="headerlink" title="location.pathname"></a>location.pathname</h4><p>返回URL中的目录和（或）文件名</p>
<h4 id="location-port"><a href="#location-port" class="headerlink" title="location.port"></a>location.port</h4><p>返回URL中指定的端口号，如果没有，返回空字符串</p>
<h4 id="location-protocol"><a href="#location-protocol" class="headerlink" title="location.protocol"></a>location.protocol</h4><p>返回页面使用过的协议</p>
<h4 id="location-search"><a href="#location-search" class="headerlink" title="location.search"></a>location.search</h4><p>返回URL的查询字符串，这个字符串以问号开头</p>
<h4 id="location-replace"><a href="#location-replace" class="headerlink" title="location.replace"></a>location.replace</h4><p>重新定向URL</p>
<p>不会在历史记录中生成新纪录</p>
<h4 id="location-reload"><a href="#location-reload" class="headerlink" title="location.reload"></a>location.reload</h4><p>重新加载当前显示的页面，也就是刷新页面</p>
<p>但是，如果页面没有更改，那么reload就会从浏览器的缓存中获取数据，不会重新请求服务器</p>
<p>如果想重新请求的话，就需要添加一个参数 <strong>true</strong></p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>从字面意思就能看到，这个对象记录了用户在浏览器中访问页面的历史记录</p>
<p>处于安全性考虑，开发者无法直接获取history对象的URL</p>
<h4 id="history-back"><a href="#history-back" class="headerlink" title="history.back"></a>history.back</h4><p>回到历史记录上一步</p>
<p>相当于使用了history.go(-1);</p>
<h4 id="history-forward"><a href="#history-forward" class="headerlink" title="history.forward"></a>history.forward</h4><p>来到历史记录的下一步</p>
<p>相当于使用了history.go(1);</p>
<h3 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h3><p>Screen对象包含有关客户端显示屏幕的信息</p>
<h4 id="screen-availWidth"><a href="#screen-availWidth" class="headerlink" title="screen.availWidth"></a>screen.availWidth</h4><p>返回可用的屏幕宽度，得到的是除了任务栏之外的内容</p>
<h4 id="screen-availHeight"><a href="#screen-availHeight" class="headerlink" title="screen.availHeight"></a>screen.availHeight</h4><p>返回可用的屏幕高度</p>
<h3 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h3><p>浏览器信息</p>
<h4 id="UserAgent"><a href="#UserAgent" class="headerlink" title="UserAgent"></a>UserAgent</h4><p>用来识别浏览器名称、版本、引擎以及操作系统等信息的内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(navigator.userAgent);</span><br></pre></td></tr></table></figure>

<p>封装检测浏览器类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowser</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> explorer = navigator.userAgent.toLowerCase();  <span class="comment">// 转换成小写好做判断</span></span><br><span class="line">    <span class="keyword">if</span>(explorer.indexOf(<span class="string">"msie"</span>)&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        browser = <span class="string">"IE"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(explorer.indexOf(<span class="string">"chrome"</span>&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        browser = <span class="string">"chrome"</span>;</span><br><span class="line">    &#125;...)</span><br><span class="line">    <span class="keyword">return</span> explorer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端 - JS</category>
      </categories>
  </entry>
</search>
