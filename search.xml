<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-Promise</title>
    <url>/2019/11/21/ES6Promise/</url>
    <content><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise对象用于表示一个异步操作的最终状态（完成或失败）以及其返回的值。</p><p>简单地说 Promise 对象中存放着未来我们要做的事情，比如一个异步操作，等操作完成之后就会返回相应的结果，成功或失败都有相应的事情做。</p><a id="more"></a>

<h1 id="传统异步操作"><a href="#传统异步操作" class="headerlink" title="传统异步操作"></a>传统异步操作</h1><p>由于JS是单线程语言，传统的异步需要依赖于回调函数的形式。</p>
<p>但是如果出现 多层操作，即这一次的操作需要依赖于 上一次异步操作返回的数据，那么就会形成多层嵌套。</p>
<p>这时代码的维护就会变得非常困难。Promise就可以解决这种问题。</p>
<p>看一下最简单的 Promise的用法 </p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-21-19-3605362029.png" alt></p>
<h1 id="对比传统回调和Promise"><a href="#对比传统回调和Promise" class="headerlink" title="对比传统回调和Promise"></a>对比传统回调和Promise</h1><p>通过一个小例子来看</p>
<h2 id="传统回调"><a href="#传统回调" class="headerlink" title="传统回调"></a>传统回调</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-26-22-512055122029.png" alt></p>
<p>可以看到会嵌套好多层，在业务复杂的时候代码维护变得极其困难。</p>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-37-19-582055822029.png" alt></p>
<h1 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h1><p>了解</p>
<p>Promise不单单解决了毁掉地狱的问题。</p>
<p>上面的例子是：    </p>
<p>在 .then 中传递了一个函数过去，然后在一个Promise的实例中根据场合调用</p>
<p>但是在我们使用第三方库的时候，我们把自己写的回调函数交给第三方库来执行，但是无法控制第三方库会怎样处理我们的回调函数，比如会不会执行、会不会多次执行等，这就出现了 <strong>控制反转</strong>，我们把控制权交给了第三方库。</p>
<p>使用Promise可以改善这种情况，比如如果调用两次 resolve的话和调用一次效果是一样的不会出现BUG。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h3 id="then的第二个参数配合reject"><a href="#then的第二个参数配合reject" class="headerlink" title="then的第二个参数配合reject"></a>then的第二个参数配合reject</h3><p>上面介绍了Promise在异步操作成功的时候做的事情，那么错误处理呢。</p>
<p>这里需要注意： Promise判断<code>then</code>，也就是 <code>resolve</code> 和 <code>reject</code> 的时候，都是异步的！ 所以 <code>try、catch</code> 对它是没有用的。</p>
<p>处理错误的方式就是在then中除了传入 <code>resolve</code> 参数之外，再传一个 <code>reject</code> 参数，对应失败时候做的事情。</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-50-07-999059992029.png" alt></p>
<p>需要注意的是，resolve和reject 只能传入一个参数供 .then 使用，如果传入了多个就拿不到了。</p>
<h3 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h3><p>这是一种错误处理方式，下面看另一种，使用 <code>catch</code>捕获错误</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-56-37-065050652029.png" alt></p>
<p>ES标准没有给到很好的无限catch的解决方案，可以持续关注</p>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-17-57-24-611056112029.png" alt></p>
<h1 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h1><p>Promise实例共有三种状态</p>
<ul>
<li>pending - 进行中</li>
<li>fulfilled - 成功</li>
<li>rejected - 失败</li>
</ul>
<p>状态只能从进行中=&gt;成功，或 进行中=&gt;失败，状态的改变称为<strong>决议</strong>，一旦决议就不能再修改。</p>
<h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h1><p>可以把多个实例重新包装成新的 promise实例。</p>
<p>接收一个数组，最后返回的也是一个promise的实例。</p>
<p>分三种情况</p>
<ol>
<li>所有promise都决议为成功，那么promise.all 就决议为成功，并把所有返回的resolve参数组合成一个数组返回，并且顺序也是一一对应的。</li>
<li>任意一个promise决议为失败，promise.all 就立即决议为失败，并且把决议失败的promise再传递出来</li>
<li>如果是空数组，promise.all 会立即决议为成功</li>
</ol>
<p>应用在 <strong>需要多个请求的数据 才能进行下一步操作的情况</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([getData1(), getData2(), getData3(), getData4()]);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">// arr 里就是上面四个方法的resolve的集合</span></span><br><span class="line">&#125;, e =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// 上面有一个决议失败就走这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不使用 promise.all 的话，就需要声明一个变量count计数，在每个异步操作成功后 count+1，最后再做判断。</p>
<h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h1><p>接收一个数组，里面也都是promise实例，不同的是</p>
<p>这么多个promise实例，一旦有一个成功了，promise.race 就会马上返回相应的promise实例，就如race竞赛的意思。</p>
<p>如果传入空数组，就会永远被挂起。</p>
<h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h1><p>表示决议成功</p>
<p>在接收参数的时候有三种情况</p>
<h2 id="传递一个普通的值"><a href="#传递一个普通的值" class="headerlink" title="传递一个普通的值"></a>传递一个普通的值</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-44-56-277052772029.png" alt></p>
<h2 id="传递一个promise实例"><a href="#传递一个promise实例" class="headerlink" title="传递一个promise实例"></a>传递一个promise实例</h2><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-47-53-3105312029.png" alt></p>
<h2 id="传递thenable对象"><a href="#传递thenable对象" class="headerlink" title="传递thenable对象"></a>传递thenable对象</h2><p>这个概念有点类似 类数组</p>
<p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-51-04-381053812029.png" alt></p>
<h1 id="看一个异步例子"><a href="#看一个异步例子" class="headerlink" title="看一个异步例子"></a>看一个异步例子</h1><p><img src="/2019/11/21/ES6Promise/PB-Snipaste-18-54-16-991059912029.png" alt></p>
<p>打印结果为 1 2 3 4 6 5</p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值</title>
    <url>/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值语法是一个JavaScript表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。</p><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-19-08-752057522014.png" alt="PB-Snipaste-11-19-08-752057522014"></p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-20-35-697056972014.png" alt="PB-Snipaste-11-20-35-697056972014"></p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-02-265052652014.png" alt="PB-Snipaste-11-21-02-265052652014"></p><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-21-378053782014.png" alt="PB-Snipaste-11-21-21-378053782014"></p><h3 id="接收多个-函数返回值"><a href="#接收多个-函数返回值" class="headerlink" title="接收多个 函数返回值"></a>接收多个 函数返回值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-21-42-545055452014.png" alt="PB-Snipaste-11-21-42-545055452014"></p><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-12-20-48-2605262014.png" alt="PB-Snipaste-12-20-48-2605262014"></p><h3 id="结合扩展运算符"><a href="#结合扩展运算符" class="headerlink" title="结合扩展运算符"></a>结合扩展运算符</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-01-16-777057772014.png" alt="PB-Snipaste-15-01-16-777057772014"></p><h3 id="对已经申明了的变量进行对象的解构赋值"><a href="#对已经申明了的变量进行对象的解构赋值" class="headerlink" title="对已经申明了的变量进行对象的解构赋值"></a>对已经申明了的变量进行对象的解构赋值</h3><a id="more"></a>







<p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-01-52-049050492014.png" alt="PB-Snipaste-15-01-52-049050492014"></p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-12-37-538055382014.png" alt="PB-Snipaste-15-12-37-538055382014"></p>
<h3 id="一些常用的用法"><a href="#一些常用的用法" class="headerlink" title="一些常用的用法"></a>一些常用的用法</h3><h4 id="使用对象传入乱序的函数参数"><a href="#使用对象传入乱序的函数参数" class="headerlink" title="使用对象传入乱序的函数参数"></a>使用对象传入乱序的函数参数</h4><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-20-33-402054022014.png" alt="PB-Snipaste-15-20-33-402054022014"></p>
<h4 id="获取多个-函数返回值"><a href="#获取多个-函数返回值" class="headerlink" title="获取多个 函数返回值"></a>获取多个 函数返回值</h4><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-23-02-361053612014.png" alt="PB-Snipaste-15-23-02-361053612014"></p>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-15-30-04-908059082014.png" alt="PB-Snipaste-15-30-04-908059082014"></p>
<h3 id="提取字符串的属性和方法"><a href="#提取字符串的属性和方法" class="headerlink" title="提取字符串的属性和方法"></a>提取字符串的属性和方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取字符串的属性或方法</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'I love my country'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; length, split &#125; = str;  <span class="comment">// length:17  split:ƒ split() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数值与布尔值的解构赋值"><a href="#数值与布尔值的解构赋值" class="headerlink" title="数值与布尔值的解构赋值"></a>数值与布尔值的解构赋值</h2><p><img src="/2019/11/14/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/PB-Snipaste-11-53-15-523055232015.png" alt="PB-Snipaste-11-53-15-523055232015"></p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>见前面的例子，传入函数的参数、取多个 函数返回值。</p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6基础及let、const</title>
    <url>/2019/11/10/ES6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h1><p>ES是JS的标准，JS是ES的实现</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>JS最初由Netscape网景公司的布兰登·艾奇发明，用于解决当时网景公司的一款浏览器Navigator的用户交互问题。</p><a id="more"></a>

<p>后来网景公司想把JS标准化，就把JS交给了ECMA组织（欧洲计算机制造联合会），而且java是当时sun公司的商标，所以就使用了ECMAScript这个名字。</p>
<h2 id="ES版本的历史"><a href="#ES版本的历史" class="headerlink" title="ES版本的历史"></a>ES版本的历史</h2><ul>
<li>1998.06 - ES2发布</li>
<li><strong>1999.12 - ES3</strong>发布，成为js的通行标准，被广大浏览器支持</li>
<li>2007.10 - ES4草案发布，内容十分激进</li>
<li>2008.07 - 将ES4小部分内容提取，发布为ES3.1，后命名为ES5</li>
<li>2009.12 - ES5发布，也就是上面说的ES3.1</li>
<li>2011.06 - ES5.1发布，并成为了ISO国际标准</li>
<li>2013.03 - ES6草案冻结，不再加入新功能</li>
<li><strong>2015.06 - ES6正式通过</strong>，成为国际标准</li>
</ul>
<p>ES6又指下一代JS标准，从2015年开始用年份来标注ES6的版本号，所以ES2016、ES2017等都是属于ES6，每个新版本的内容都会依赖于之前的版本，所以这次笔记为ES2015。</p>
<h1 id="let与块级作用域"><a href="#let与块级作用域" class="headerlink" title="let与块级作用域"></a>let与块级作用域</h1><p>之前声明变量一般会使用 </p>
<ol>
<li><pre><code class="javascript"><span class="comment">// var关键字</span>
<span class="keyword">var</span> name;
<span class="keyword">var</span> age = <span class="number">18</span>;
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ol>
<p>let和var相似，也是对变量进行声明。</p>
<p>那区别呢？</p>
<h3 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h3><p>let声明的变量只在当前（块级）作用域内有效。</p>
<p>var声明的变量只在当前作用域内有效。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123111-22-16.png" alt="Snipaste_123111-22-16"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123412-23-22.png" alt="Snipaste_2020-05-13_16-23-22"></p>
<p>let声明的变量不能被重复声明。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_1245233fd14-11.png" alt="Snipaste_1245233fd14-11"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_5662sa1135-29.png" alt="Snipaste_5662sa1135-29"></p>
<p>不存在变量提升。</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_55112advo213_16-38-56.png" alt="Snipaste_55112advo213_16-38-56"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_123xdz11234f71-13_16-39-36.png" alt="Snipaste_123xdz11234f71-13_16-39-36"></p>
<h2 id="ES6之前的作用域"><a href="#ES6之前的作用域" class="headerlink" title="ES6之前的作用域"></a>ES6之前的作用域</h2><p>全局作用域</p>
<p>函数作用域</p>
<p>eval作用域</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>通俗的说 就是一对花括号中的区域 <code>{ ... }</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如</span></span><br><span class="line"><span class="keyword">if</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> () &#123;&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 注意： 声明一个对象的时候，花括号就不再是块级作用域了</span></span><br></pre></td></tr></table></figure>

<p>块级作用域可以嵌套</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 块级作用域1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 块级作用域2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暂存死区"><a href="#暂存死区" class="headerlink" title="暂存死区"></a>暂存死区</h2><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_812312asd1-59-52.png" alt="Snipaste_812312asd1-59-52"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_6234sad13-13_17-00-37.png" alt="Snipaste_6234sad13-13_17-00-37"></p>
<p>ES6规定，如果块级作用域中存在 <code>let</code> <code>const</code> 声明的变量，那么一开始就会形成一个封闭的作用域。</p>
<p>简单说，即使向上的作用域中存在同名变量也是拿不到的。</p>
<h2 id="let小例子"><a href="#let小例子" class="headerlink" title="let小例子"></a>let小例子</h2><p>Q：生成10个按钮，每个按点击的时候弹出 1 - 10</p>
<h3 id="使用var实现"><a href="#使用var实现" class="headerlink" title="使用var实现"></a>使用var实现</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_213dsf3125-40.png" alt="Snipaste_213dsf3125-40"></p>
<h3 id="使用let实现"><a href="#使用let实现" class="headerlink" title="使用let实现"></a>使用let实现</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_213fsa27-29-50.png" alt="Snipaste_213fsa27-29-50"></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>用来声明常量 - 不可改变的量</p>
<p>和声明变量一样，基本只是关键字的区别</p>
<p>常量必须在声明的时候赋值，否则会报错</p>
<p>与let类似的特征</p>
<ul>
<li>不能重复声明</li>
<li>不存在提升</li>
<li>只在当前（块级）作用域内有效</li>
</ul>
<p>常量不可被修改，但是当常量为引用类型的时候，不能保证不可变</p>
<p>因为const只能保证常量指向的地址不变</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste4azd134-28-26-18.png" alt="Snipaste4azd134-28-26-18"></p>
<p>同为引用类型的数组和函数也是同样道理。</p>
<h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h2><h3 id="Q：怎么解决引用类型的常量可以被修改的问题"><a href="#Q：怎么解决引用类型的常量可以被修改的问题" class="headerlink" title="Q：怎么解决引用类型的常量可以被修改的问题"></a>Q：怎么解决引用类型的常量可以被修改的问题</h3><p>使用 <code>Object.freeeze()</code></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste1292234sad11-29.png" alt="Snipaste1292234sad11-29"></p>
<p>此函数对数组、函数同样有效。对数组使用的时候，如果修改数组会报错。</p>
<h3 id="Q：ES6之前怎么声明常量"><a href="#Q：ES6之前怎么声明常量" class="headerlink" title="Q：ES6之前怎么声明常量"></a>Q：ES6之前怎么声明常量</h3><p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_25xq2a243-13.png" alt="Snipaste_25xq2a243-13"></p>
<p>同时使用 <code>Object.defineProperty()</code> 和 <code>Object.seal()</code> 可以实现 <code>Object.freeze()</code>的效果</p>
<p>那么就来自己封装一个 <code>freeze</code>函数</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_5123asa7-53-30.png" alt="Snipaste_5123asa7-53-30"></p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste2677dd1353-58.png" alt="Snipaste2677dd1353-58"></p>
<p>这样就做好了一个简单的封装，但是如果遇到属性还是Obj的情况就仍然无法保证，下面改进一下</p>
<p><img src="/2019/11/10/ES6%E5%9F%BA%E7%A1%80/Snipaste_t234a123ad2119-03-10.png" alt="Snipaste_t234a123ad2119-03-10"></p>
]]></content>
      <categories>
        <category>前端 - ES6</category>
      </categories>
  </entry>
  <entry>
    <title>Sass</title>
    <url>/2020/02/10/Sass/</url>
    <content><![CDATA[<h1 id="Sass基础"><a href="#Sass基础" class="headerlink" title="Sass基础"></a>Sass基础</h1><h2 id="Sass整体介绍"><a href="#Sass整体介绍" class="headerlink" title="Sass整体介绍"></a>Sass整体介绍</h2><p>官网介绍Sass是CSS扩展语言。Sass是基于Ruby语言开发的。</p><p>CSS预处理工具。</p><p>需要前置文件，然后进行编译解析，最后生成CSS。</p><p> <img src="/2020/02/10/Sass/image-20191219145953928.png" alt></p><ul>
<li><p>嵌套规则</p>
<p>通过花括号的方式解决复杂的css父子样式嵌套问题。</p>
</li>
<li><p>变量规则</p>
<p>通过变量将公共样式抽离，减少冗余css代码。</p>
</li>
<li><p>条件逻辑</p>
<p>向高级语言一样编写逻辑性的css代码</p>
</li>
</ul><a id="more"></a>




<h1 id="Sass基础知识"><a href="#Sass基础知识" class="headerlink" title="Sass基础知识"></a>Sass基础知识</h1><h2 id="变量和引用"><a href="#变量和引用" class="headerlink" title="变量和引用"></a>变量和引用</h2><ul>
<li><p>定义</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规类型</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="comment">// 颜色类型</span></span><br><span class="line"><span class="variable">$color</span>: <span class="number">#e03434</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default语法</span></span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">100px</span>;  <span class="comment">// 如果这么写，200就会被100覆盖掉</span></span><br><span class="line"><span class="variable">$baseWidth</span>: <span class="number">100px</span> default;  <span class="comment">// 加上default语法的话，100就变成了默认值，其他地方可以把这个值覆盖掉。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="variable">$str</span>: <span class="string">'hello.jpeg'</span>;  <span class="comment">// 加引号的字符串</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>-<span class="selector-tag">img</span>: url(<span class="string">'./img/'</span>+<span class="variable">$str</span>);  <span class="comment">// 字符串可以拼接，使用+</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$strNoQout</span>: abc;  <span class="comment">// 也可以正常使用</span></span><br><span class="line"><span class="comment">// 字符串连接，插值变量的语法</span></span><br><span class="line"><span class="attribute">background</span>-<span class="selector-tag">img</span>: url(<span class="string">'./img/#&#123;$strNoQout'</span>&#125;);  <span class="comment">// #&#123;&#125;</span></span><br><span class="line"><span class="comment">// 插值变量还可以用在很多地方</span></span><br><span class="line"><span class="variable">$class</span>: <span class="string">'.div'</span>;</span><br><span class="line">#&#123;<span class="variable">$class</span>&#125;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#ffe932</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$height</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$widthInner</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$widthInner</span>;  <span class="comment">// 这里不会报错，可以找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$widthInner</span>;  <span class="comment">// 这里会报错，找不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>import</p>
<p>css原生在每次import的时候都需要发送请求，不友好不推荐使用。</p>
<p>sass的import是在编译的时候一起编译。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了和css原生的import区分开，sass约定，满足一下四个条件中的任何一个，sass在编译的时候就不会编译成sass特有的语法</span></span><br><span class="line"><span class="comment">1. import的是以 .css结尾的名字</span></span><br><span class="line"><span class="comment">2. import的是以 http:// 开头的</span></span><br><span class="line"><span class="comment">3. 使用url()包裹的</span></span><br><span class="line"><span class="comment">4. 引入任何 media queries 的样式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'.org.css'</span>;  <span class="comment">// 这种形式会认为是css原生的import</span></span><br><span class="line">$width: <span class="number">300</span>px;</span><br><span class="line">$color: #ffe932;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在sass中约定，将想要引入的文件以下划线_开头，在引入的时候把 下划线和扩展名 去掉。</span></span><br><span class="line"><span class="comment">// 新建 _base.sass 文件</span></span><br><span class="line">@<span class="keyword">import</span> base;  <span class="comment">// 去掉 下划线和扩展名 引入。</span></span><br><span class="line">$width: <span class="number">300</span>px;</span><br><span class="line">$color: #ffe932;</span><br></pre></td></tr></table></figure>

<p>import的位置不同，可能会出现声明的变量被覆盖的情况，如果想避免这种情况，就可以使用default生命方式，所以被引入的文件中的变量如果使用default方式声明的话，就不需要担心了。</p>
</li>
</ul>
<h1 id="Sass数据类型"><a href="#Sass数据类型" class="headerlink" title="Sass数据类型"></a>Sass数据类型</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$zoomValue</span>: <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// color</span></span><br><span class="line"><span class="variable">$color</span>: red;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#ffe932</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="variable">$str</span>: <span class="string">'hello.jpeg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="variable">$list</span>: (<span class="number">100px</span>, <span class="number">200px</span>, <span class="number">300px</span>, <span class="number">400px</span>, <span class="number">2</span>, <span class="string">'string'</span>);</span><br><span class="line"><span class="comment">// list 的常见用法</span></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: nth(<span class="variable">$list</span>, <span class="number">1</span>);  <span class="comment">// nth方法 提取到了list的第1个元素，而且下标是从1开始的。</span></span><br><span class="line">    <span class="attribute">height</span>: nth(<span class="variable">$list</span>, <span class="number">2</span>);</span><br><span class="line">    zoom: nth(<span class="variable">$list</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index 找到指定元素的数字下标</span></span><br><span class="line">index($list, 'string');  // 6</span><br><span class="line"></span><br><span class="line"><span class="comment">// map  类似对象</span></span><br><span class="line"><span class="variable">$map</span>: (top: <span class="number">1px</span>, left: <span class="number">2px</span>, bottom: <span class="number">3px</span>, right: <span class="number">4px</span>);</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: map-get(<span class="variable">$map</span>, top);  <span class="comment">// 使用map-get 方法，传入key获取value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="keyword">@each</span> <span class="variable">$key</span>, <span class="variable">$value</span> in <span class="variable">$map</span> &#123;  <span class="comment">// 把map遍历一下，然后依次把key作为属性，value作为值</span></span><br><span class="line">        #&#123;<span class="variable">$key</span>&#125;: <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass基本运算"><a href="#Sass基本运算" class="headerlink" title="Sass基本运算"></a>Sass基本运算</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$num1</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="variable">$num2</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$width</span>: <span class="variable">$num1</span> + <span class="variable">$num2</span>;  <span class="comment">// 加</span></span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加减乘除</span></span><br><span class="line"><span class="attribute">font</span>: (<span class="number">10px</span> / <span class="number">8</span>);  <span class="comment">// 除法， 1.5px</span></span><br><span class="line"><span class="attribute">font</span>: (<span class="number">10px</span> * <span class="number">8</span>);  <span class="comment">// 乘法, </span></span><br><span class="line"><span class="attribute">width</span>: <span class="variable">$width</span> / <span class="number">2</span>;  <span class="comment">// 使用变量就不需要加括号了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 颜色运算</span></span><br><span class="line"><span class="variable">$color1</span>: <span class="number">#010203</span>;</span><br><span class="line"><span class="variable">$color2</span>: <span class="number">#040506</span>;</span><br><span class="line"><span class="variable">$color3</span>: <span class="number">#a69e61</span>;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$color1</span> + <span class="variable">$color2</span>;  <span class="comment">// 会警告，直接颜色相加的方式已经过期，后期可能会废弃，建议使用color方法   结果： #050509，是对每一位进行相加</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">color</span>: mix(<span class="variable">$color1</span>, <span class="variable">$color2</span>);  <span class="comment">// 混合色， #030405</span></span><br><span class="line">    <span class="attribute">color</span>: red(<span class="variable">$color3</span>);  <span class="comment">// 166</span></span><br><span class="line">    <span class="attribute">color</span>: green(<span class="variable">$color3</span>);  <span class="comment">// 158</span></span><br><span class="line">    <span class="attribute">color</span>: blue(<span class="variable">$color3</span>);  <span class="comment">// 97</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串运算</span></span><br><span class="line">$str = 'hello.jpeg';</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'images/'</span>+<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mixin 语法块</span></span><br><span class="line"><span class="comment">// 一般的mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> helloMixin &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        size: <span class="number">20px</span>;</span><br><span class="line">        weight: <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套mixin 一定要注意是否使用了相同的属性</span></span><br><span class="line"><span class="keyword">@mixin</span> helloMixin2 &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        size: <span class="number">20px</span>;</span><br><span class="line">        weight: <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="keyword">@include</span> helloMixin2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数mixin</span></span><br><span class="line"><span class="keyword">@mixin</span> sexy-border(<span class="variable">$color</span>, <span class="variable">$width</span>)&#123;</span><br><span class="line">    <span class="attribute">border</span>: &#123;</span><br><span class="line">        color: <span class="variable">$color</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="selector-tag">style</span>: dashed;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="variable">$include</span> sexy-<span class="attribute">border</span>(blue, 2px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass继承-extend"><a href="#Sass继承-extend" class="headerlink" title="Sass继承  @extend"></a>Sass继承  @extend</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单继承</span></span><br><span class="line">.div &#123;</span><br><span class="line">    border: <span class="number">1</span>px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.divext &#123;</span><br><span class="line">    @extend .div;</span><br><span class="line">    border-width: <span class="number">3</span>px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联属性继承</span></span><br><span class="line">.div1 &#123;</span><br><span class="line">    border: <span class="number">1</span>px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.div1.other &#123;</span><br><span class="line">    background-image: url(<span class="string">'hello.jpeg'</span>);</span><br><span class="line">&#125;</span><br><span class="line">.divext &#123;</span><br><span class="line">    @extend .div;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式继承</span></span><br><span class="line">.div1 &#123;</span><br><span class="line">    border: 1px soild #000;</span><br><span class="line">&#125;</span><br><span class="line">.div2 &#123;</span><br><span class="line">    @extend .div1;</span><br><span class="line">    color: #red;</span><br><span class="line">&#125;</span><br><span class="line">.div3 &#123;</span><br><span class="line">    @extend .div2;</span><br><span class="line">    color: #000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链式继承中，相同的属性名是不会合并的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪类继承</span></span><br><span class="line">a:hover &#123;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink &#123;</span><br><span class="line">    color: red;</span><br><span class="line">    @extend :hover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 效果：</span></span><br><span class="line">a:hover, a.hoverlink &#123;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.hoverlink &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass嵌套"><a href="#Sass嵌套" class="headerlink" title="Sass嵌套"></a>Sass嵌套</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过括号的层级让代码更清晰</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="variable">$color</span>: <span class="number">#fff</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.div-inner</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-class">.div-inner-inner</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种嵌套方法： css中以横杠- 隔开的属性都可以用mixin的方式写</span></span><br><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#c</span>olor;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-class">.div-inner</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: &#123;</span><br><span class="line">            left: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="attribute">background</span>: &#123;</span><br><span class="line">            image: url(<span class="string">'abc.png'</span>);</span><br><span class="line">            <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Sass的条件控制语句"><a href="#Sass的条件控制语句" class="headerlink" title="Sass的条件控制语句"></a>Sass的条件控制语句</h1><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line">$type = 'tony';</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$type</span> == <span class="string">'bufy'</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if type == <span class="string">'tim'</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if <span class="variable">$type</span> == <span class="string">'tony'</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@if</span> <span class="variable">$type</span> == <span class="string">'bufy'</span> &#123;</span><br><span class="line">    <span class="selector-class">.div</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="selector-class">.div</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;  <span class="comment">// through 可以改为 to，使用through的话包括3，to知道2 </span></span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 效果</span></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for list</span></span><br><span class="line"><span class="variable">$list</span>: (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> to length(list) &#123;</span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="selector-class">.item</span>#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">1px</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$i</span>: <span class="variable">$i-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>sass：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194025755.png" alt></p>
<p>css：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194034623.png" alt></p>
<h1 id="Sass内置函数"><a href="#Sass内置函数" class="headerlink" title="Sass内置函数"></a>Sass内置函数</h1><h2 id="number函数"><a href="#number函数" class="headerlink" title="number函数"></a>number函数</h2><p> <img src="/2020/02/10/Sass/image-20200303194153328.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194241320.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194303377.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194317185.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194331151.png" alt></p>
<p>sass：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194849896.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303194820090.png" alt></p>
<p>css：</p>
<p> <img src="/2020/02/10/Sass/image-20200303194908607.png" alt></p>
<h2 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h2><p> <img src="/2020/02/10/Sass/image-20200303194736306.png" alt></p>
<h2 id="str函数"><a href="#str函数" class="headerlink" title="str函数"></a>str函数</h2><p> <img src="/2020/02/10/Sass/image-20200303195258931.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303195434044.png" alt></p>
<h2 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h2><p> <img src="/2020/02/10/Sass/image-20200303195812958.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200329863.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200339446.png" alt></p>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p> <img src="/2020/02/10/Sass/image-20200303200758016.png" alt></p>
<p> <img src="/2020/02/10/Sass/image-20200303200810926.png" alt></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>GitLab搭建(docker环境)</title>
    <url>/2020/03/01/Gitlab/</url>
    <content><![CDATA[<h1 id="Gitlab优点"><a href="#Gitlab优点" class="headerlink" title="Gitlab优点"></a>Gitlab优点</h1><p>Gitlab也是一个git平台，管理仓库和项目</p><ul>
<li>现在很多Git平台对团队协作人数有限制</li>
<li>可定制化对接自动化平台Jenkins</li>
<li>可定制样式、哪些邮箱可以注册</li>
<li>可设置每个用户可以上传的文件数的大小</li>
</ul><a id="more"></a>

<h1 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h1><p>参考： <a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">官方文档</a>，找到<a href="https://docs.gitlab.com/ee/install/docker.html" target="_blank" rel="noopener">以Docker方式安装</a>。</p>
<p>可以找到最简单的一种方法来快速进行GitLab平台的测试和运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  --publish 443:443 --publish 80:80 --publish 22:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/config:/etc/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/logs:/var/log/gitlab \</span><br><span class="line">  --volume $GITLAB_HOME/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：各种参数的意义： </p>
<ul>
<li>–detach： 等同于 <code>-d</code> ，后台运行。</li>
<li>–hostname：指定域名，建议使用云服务器，域名指向IP，可以更方便的访问和迁移。也可以是虚拟机的IP。</li>
<li>–publish： 一些端口的映射，前面的数字是宿主机的端口。</li>
<li>–name gitlab：指定的镜像的名称。</li>
<li>–restart：当Docker服务重启的时候，GitLab服务自动重启。</li>
<li>–volume：Docker容器内的GitLab服务的数据映射到宿主机上。</li>
</ul>
</blockquote>
<p>下面就在虚拟机里修改一下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里只做测试运行，所以删除了一些参数</span></span><br><span class="line">sudo docker run --detach \</span><br><span class="line">  --hostname 192.168.1.117 \</span><br><span class="line">  --publish 18800:80 --publish 12222:22 \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --restart always \</span><br><span class="line">  gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附： 开放防火墙端口</p>
<p><code>firewall-cmd --add-port=18800/tcp --permanent</code></p>
<p><code>firewall-cmd --reload</code></p>
</blockquote>
<p>等待一下，可以通过<code>docker logs -f xxxx</code> 来实时打印gitlab的日志查看</p>
<p><em>注： 这种方法没有传入任何的username和pwd，默认用户名是root，在第一次访问的时候提示设置管理员密码。</em></p>
<p>访问页面大概长这个样子。</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-01-07-19-351043512025.png" alt="PB-Snipaste-01-07-19-351043512025"></p>
<p>但是使用 <code>docker run</code> 快速生成的gitlab服务远达不到生产的需求，比如没有HTTPS协议、SSH克隆项目的默认端口设置、邮件提示服务（merge request）、找回密码等等。</p>
<h1 id="使用docker-compose-搭建"><a href="#使用docker-compose-搭建" class="headerlink" title="使用docker-compose 搭建"></a>使用docker-compose 搭建</h1><p>同样在官方文档中有<a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" target="_blank" rel="noopener">install GitLab using docker-compose</a></p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-12-54-17-763047632025.png" alt="PB-Snipaste-12-54-17-763047632025"></p>
<p>我们选择更方便的方法</p>
<p>在github上有 <a href="https://github.com/sameersbn/docker-gitlab" target="_blank" rel="noopener">docker-gitlab</a> 项目，里面有很多功能比如升级、备份、恢复、邮箱等等功能都准备好了。</p>
<p>找到项目中的 <a href="https://github.com/sameersbn/docker-gitlab/blob/master/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 文件，文件很长，我们按需设置就行了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_HOST=localhost</span>  <span class="comment"># IP地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_PORT=10080</span>  <span class="comment"># gitlab端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SSH_PORT=10022</span> <span class="comment"># SSH端口</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_RELATIVE_URL_ROOT=</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alphanumeric-string</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_ROOT_PASSWORD=</span> <span class="comment"># gitlab 密码</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_ROOT_EMAIL=</span> <span class="comment"># 管理员邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_HTTPS=false</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">SSL_SELF_SIGNED=false</span> <span class="comment"># 是否使用自签名的方式，如果是自申请的证书，则需要在gitlab加载一下证书</span></span><br></pre></td></tr></table></figure>

<p>配置好 <code>.yml</code> 文件后，就可以使用 <code>docker-compose up -d</code> ，创建运行了，创建的过程可能会持续数分钟，可以使用 <code>docker logs -f xxx</code> 来查看进度。</p>
<p>然后就可以访问服务并创建项目了。</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-35-43-379043792025.png" alt="PB-Snipaste-13-35-43-379043792025"></p>
<h1 id="GitLab平台的备份-amp-恢复"><a href="#GitLab平台的备份-amp-恢复" class="headerlink" title="GitLab平台的备份&amp;恢复"></a>GitLab平台的备份&amp;恢复</h1><h2 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h2><p>使用上述方法创建的镜像已经帮我们设置好了一个定时任务，备份的周期是天。</p>
<p>可以在 <code>.yml</code> 文件内查看到。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_BACKUP_SCHEDULE=daily</span> <span class="comment"># 周期是天</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITLAB_BACKUP_TIME=01:00</span> <span class="comment"># 在每一天01:00时备份</span></span><br></pre></td></tr></table></figure>

<h2 id="设置超期时间"><a href="#设置超期时间" class="headerlink" title="设置超期时间"></a>设置超期时间</h2><p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-52-14-579045792025.png" alt="PB-Snipaste-13-52-14-579045792025"></p>
<p>默认数值是按秒计算的，如果想要每七天设置一下超时的话，就要设置为604800秒。</p>
<p>如果不设置，backup都会被保存下来。</p>
<p>重新编辑 <code>.yml</code>文件，在如下位置添加 <code>- GITLAB_BACKUP_EXPIRY=604800</code> </p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-55-38-295042952025.png" alt="PB-Snipaste-13-55-38-295042952025"></p>
<p>这样在第八天就会自动删除第一天的备份。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新配置文件</span></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h2><p>在github文档中可以查到方法</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-13-47-19-517045172025.png" alt="PB-Snipaste-13-47-19-517045172025"></p>
<h3 id="使用docker-compose手动备份"><a href="#使用docker-compose手动备份" class="headerlink" title="使用docker-compose手动备份"></a>使用docker-compose手动备份</h3><p>使用 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:create</span><br></pre></td></tr></table></figure>

<p>就备份好了。</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:restore # List available backups</span><br><span class="line">docker-compose run --rm gitlab app:rake gitlab:backup:restore BACKUP=1417624827 # Choose to restore from 1417624827</span><br></pre></td></tr></table></figure>

<p>首先查看备份文件list</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-02-02-789047892025.png" alt="PB-Snipaste-14-02-02-789047892025"></p>
<p>然后将想要恢复的文件名复制粘贴进去即可</p>
<p><code>1587794387_2020_04_25_12.9.2_gitlab_backup.tar</code></p>
<p>会提示： 一旦恢复所有数据库将被覆盖，是否继续，键入yes即可。</p>
<h1 id="GitLab的权限"><a href="#GitLab的权限" class="headerlink" title="GitLab的权限"></a>GitLab的权限</h1><p>团队协作中可能出现的问题：</p>
<p>如果把所有的分支全部开放，某人误推送到了主干分支（生产分支）上了，可能会导致一些不可预期的问题。那么就进行权限控制。</p>
<h2 id="权限控制思路"><a href="#权限控制思路" class="headerlink" title="权限控制思路"></a>权限控制思路</h2><ul>
<li><p>以组为单元，设置管理员。</p>
<p>所有参与项目的人员为一个组，管理员负责项目分支的合并，管理员设置主干分支、哪些成员可以添加进来查看。</p>
</li>
<li><p>熟悉Merge Request，写好git commit。</p>
</li>
<li><p>及时回收权限，或者设置过期时间。</p>
<p>注意，回收权限时不要删除成员，只把权限回收即可。因为如果删除成员的话就会把他的历史提交一并删除掉，无法溯源。</p>
</li>
</ul>
<p>建议的角色分配</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-21-31-353043532025.png" alt="PB-Snipaste-14-21-31-353043532025"></p>
<h2 id="组管理-amp-组权限"><a href="#组管理-amp-组权限" class="headerlink" title="组管理&amp;组权限"></a>组管理&amp;组权限</h2><p>GitLab的组类似GitHub上组织的概念</p>
<p>比如来了一个 <code>frontend-group1</code> 项目组，</p>
<p><img src="/2020/03/01/Gitlab/PB-Snipaste-14-24-44-3404342025.png" alt="PB-Snipaste-14-24-44-3404342025"></p>
<p>然后就可以设置组权限，注意这里设置的权限是针对所有项目的权限，和之前的项目权限做区分。</p>
<h2 id="分支保护"><a href="#分支保护" class="headerlink" title="分支保护"></a>分支保护</h2><p>在 项目 - 设置 - 仓库 - Protected Branches 中设置受保护的分支、允许推送和合并的Roles。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker快速上手</title>
    <url>/2020/01/20/docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="/2020/01/20/docker/docker01.png" alt="img"></p><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><a id="more"></a>


<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p>
<p>docker技术主要应用在<strong>容器化应用</strong>上。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-12-31-52-403044032023.png" alt="PB-Snipaste-12-31-52-403044032023"></p>
<h1 id="docker虚拟技术和传统虚拟机区别"><a href="#docker虚拟技术和传统虚拟机区别" class="headerlink" title="docker虚拟技术和传统虚拟机区别"></a>docker虚拟技术和传统虚拟机区别</h1><p><img src="/2020/01/20/docker/PB-Snipaste-12-39-01-539045392023.png" alt="PB-Snipaste-12-39-01-539045392023"></p>
<h1 id="docker主要特性"><a href="#docker主要特性" class="headerlink" title="docker主要特性"></a>docker主要特性</h1><ul>
<li>文件、资源、网络隔离</li>
<li><strong>变更管理</strong>、日志记录</li>
<li><strong>写时复制</strong>的方式创建的根文件系统</li>
</ul>
<h1 id="docker安装演示"><a href="#docker安装演示" class="headerlink" title="docker安装演示"></a>docker安装演示</h1><p>环境：</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-12-58-02-728047282023.png" alt="PB-Snipaste-12-58-02-728047282023"></p>
<h2 id="删除之前安装过的docker"><a href="#删除之前安装过的docker" class="headerlink" title="删除之前安装过的docker"></a>删除之前安装过的docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure>

<h2 id="添加stable的Docker-ce源"><a href="#添加stable的Docker-ce源" class="headerlink" title="添加stable的Docker-ce源"></a>添加stable的Docker-ce源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h2><p>使用 <code>systemctl start docker</code> 运行起docker来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>查看docker进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/20/docker/PB-Snipaste-13-18-19-128041282023.png" alt="PB-Snipaste-13-18-19-128041282023"></p>
<h2 id="第一个docker应用-hello-world"><a href="#第一个docker应用-hello-world" class="headerlink" title="第一个docker应用 - hello-world"></a>第一个docker应用 - hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/20/docker/PB-Snipaste-13-22-58-499044992023.png" alt="PB-Snipaste-13-22-58-499044992023"></p>
<h2 id="使用docker中国官方镜像加速"><a href="#使用docker中国官方镜像加速" class="headerlink" title="使用docker中国官方镜像加速"></a>使用docker中国官方镜像加速</h2><p>编辑 <code>/etc/docker/daemon.json</code> ，没有就创建改文件</p>
<p>添加以下内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"registry-mirrors"</span> : [<span class="string">"https://docker.mirrors.ustc.edu.cn"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启 daemon和docker进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p><em>附： ubuntu上可以使用 <code>service docker restart</code></em> 重启docker镜像</p>
<h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><ul>
<li><p><code>docker ps</code> 查看正在运行的容器</p>
</li>
<li><p><code>docker ps -a</code> 查看所有容器</p>
</li>
<li><p><code>docker stop &lt;id/name&gt;</code> 停止容器</p>
</li>
<li><p><code>docker rm &lt;id/name&gt;</code> 删除一个已经停止的容器</p>
<p><em>注：正在运行的容器是无法删除的</em></p>
</li>
<li><p><code>docker logs -f &lt;id/name&gt;</code>  打印log -f表示持续打印</p>
</li>
<li><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code> 在运行的容器中执行命令</p>
<ul>
<li><strong>-d :</strong>分离模式: 在后台运行</li>
<li><strong>-i :</strong>即使没有附加也保持STDIN 打开</li>
<li><strong>-t :</strong>分配一个伪终端</li>
</ul>
<p><em>附：进入docker容器 <code>docker exec -i -t  &lt;id/name&gt;/bin/bash</code></em></p>
</li>
</ul>
<h2 id="安装mysql的docker容器"><a href="#安装mysql的docker容器" class="headerlink" title="安装mysql的docker容器"></a>安装mysql的docker容器</h2><p>进入 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>， 找到mysql容器的安装方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></table></figure>

<p>替换一些参数，自定义一下容器名和密码，这里缺省了 <code>:tag</code> ，就会默认拉取最新的镜像，也可以将<code>tag</code> 设置为想要拉取的版本，参数 <code>-d</code> 意思是后台运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zy-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>

<p>然后可以使用 docker ps 查看下载好的镜像了</p>
<h3 id="映射mysql服务的端口号-p"><a href="#映射mysql服务的端口号-p" class="headerlink" title="映射mysql服务的端口号 -p"></a>映射mysql服务的端口号 <code>-p</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name zy-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 23457:3306 -d mysql</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>-p</code>参数后跟着的 <code>23457:3306</code> ，前面的数字代表 外部（宿主机）端口，后面的数字代表docker内部的端口</p>
<h2 id="进入容器看一眼"><a href="#进入容器看一眼" class="headerlink" title="进入容器看一眼"></a>进入容器看一眼</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it zy-mysql /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="退出docker容器"><a href="#退出docker容器" class="headerlink" title="退出docker容器"></a>退出docker容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p>一个场景：当我们有多个docker容器需要统一管理的时候，难道要一个个的run、stop吗？</p>
<p>显然这样操作太繁琐。</p>
<p>这时就需要一个集成工具，来帮我们统一管理多个docker镜像，查看、启动、停止等。</p>
<p>使用一个 <code>.yml</code> 文件来统一管理。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-16-04-18-727047272024.png" alt="PB-Snipaste-16-04-18-727047272024"></p>
<h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><p>参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">sudo curl -L "https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 给予执行权限</span></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>附：安装后执行docker-compose提示 <a href="https://blog.csdn.net/alen_xiaoxin/article/details/104849962" target="_blank" rel="noopener">Cannot open self /usr/local/bin/docker-compose or archive /usr/local/bin/docker-compoe.pkg解决办法</a></p>
</blockquote>
<h2 id="编辑-docker-compose-yml-文件"><a href="#编辑-docker-compose-yml-文件" class="headerlink" title="编辑 docker-compose.yml 文件"></a>编辑 docker-compose.yml 文件</h2><p>这里演示启动两个 mysql服务，<code>mysql1</code> 和 <code>mysql2</code></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-38-50-639046392024.png" alt="PB-Snipaste-17-38-50-639046392024"></p>
<p><em>附： 上图有语法错误，line8、15 的 <code>-</code> 后面应有一个空格</em></p>
<h2 id="批量启动镜像"><a href="#批量启动镜像" class="headerlink" title="批量启动镜像"></a>批量启动镜像</h2><p>然后就可以使用 <code>docker-compose up -d</code> 根据 <code>.yml</code>文件配置来创建两个容器了</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-52-35-335043352024.png" alt="PB-Snipaste-17-52-35-335043352024"></p>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>使用<code>docker-compose stop</code> 批量停止</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-59-08-911049112024.png" alt="PB-Snipaste-17-59-08-911049112024"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>docker-compose rm</code></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-17-59-56-488044882024.png" alt="PB-Snipaste-17-59-56-488044882024"></p>
<h1 id="使用Docker-hub-提交、拉取自己的镜像"><a href="#使用Docker-hub-提交、拉取自己的镜像" class="headerlink" title="使用Docker hub 提交、拉取自己的镜像"></a>使用<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a> 提交、拉取自己的镜像</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>使用 <code>docker login</code> 可以登录自己的docker账号，然后就可以提交和拉取了</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-04-21-3604362024.png" alt="PB-Snipaste-18-04-21-3604362024"></p>
<h2 id="创建image"><a href="#创建image" class="headerlink" title="创建image"></a>创建image</h2><p>使用 <code>docker commit 57d92a983a62（容器id） &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code> 来创建镜像</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-08-26-511045112024.png" alt="PB-Snipaste-18-08-26-511045112024"></p>
<p>使用 <code>docker images</code> 看一眼自己的镜像</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-09-50-903049032024.png" alt="PB-Snipaste-18-09-50-903049032024"></p>
<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p><code>docker push &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code></p>
<p>有一些已经存在远端的文件就会 Mounted ，不会再次推送，节约了推送的时间。</p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-12-00-167041672024.png" alt="PB-Snipaste-18-12-00-167041672024"></p>
<p><img src="/2020/01/20/docker/PB-Snipaste-18-15-18-227042272024.png" alt="PB-Snipaste-18-15-18-227042272024"></p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>推送成功后可以在随意一台机器上使用 <code>docker pull &lt;dockerhub前缀&gt;/&lt;上传的name&gt;[:tag]</code> 拉取镜像了</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Git</title>
    <url>/2019/12/28/git/</url>
    <content><![CDATA[<h1 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h1><p>生成命令：</p><p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></p><h1 id="场景一：空仓库-amp-创建仓库提交代码"><a href="#场景一：空仓库-amp-创建仓库提交代码" class="headerlink" title="场景一：空仓库&amp;创建仓库提交代码"></a>场景一：空仓库&amp;创建仓库提交代码</h1><p>新建一个文件夹，执行 <code>git init</code>命令初始化一个本地仓库</p><a id="more"></a>


<p>这时会在文件夹中创建一个 <code>/.git/</code> 的文件夹</p>
<p>这个文件夹里面放的全部都是文件的<strong>快照</strong>，这些快照会有多个状态，git就是通过管理这些快照来对代码、文件进行版本管理的。</p>
<p>下面可以通过 <code>git add exampleFile</code>  命令添加文件到git的管理仓库里了</p>
<p>使用 <code>git status</code> 查看文件<strong>缓存</strong>的状态，有没有文件放在了待提交的区域</p>
<p>注： git有两种操作： <code>add</code> 、 <code>commit</code>  只有commit操作后才会拍一个快照，这个<strong>快照就是一次提交</strong></p>
<p><code>git commit -m &quot;first commit&quot;</code>  ， commit命令就把文件从缓存区提交到了本地仓库中，也就是一次快照。</p>
<p>这时再使用 <code>git status</code> 查看状态就会显示</p>
<p> <img src="/2019/12/28/git/image-20200419125654052.png" alt></p>
<p>此时如果使用 <code>git push origin master</code> ，会提示 不存在</p>
<p> <img src="/2019/12/28/git/image-20200419125706549.png" alt></p>
<p>因为origin（初始）是自己创建出来的，要使用<code>git remote</code>创建，来告诉git需要推送到哪个远程仓库上去</p>
<p><code>git remote add origin git@github.com:xx/learngit-1.git</code></p>
<p> <em>附： <code>git clone</code> 命令会自动设置好 origin</em></p>
<p>使用 <code>git remote add origin git@xx.com:xxx.git</code>，就可以push到远程仓库了</p>
<h1 id="场景二：-推送代码到多个仓库"><a href="#场景二：-推送代码到多个仓库" class="headerlink" title="场景二： 推送代码到多个仓库"></a>场景二： 推送代码到多个仓库</h1><p>可以使用 <code>git remote -v</code> 查看是否已经有远程仓库的地址</p>
<p>创景概述：</p>
<p>同一个本地git仓库，可以分别给不同的远程仓库提交，就需要设置不同的<code>origin</code>来做远程仓库的区分</p>
<p>新建一个空的远程仓库</p>
<p>并在本地git仓库中执行 <code>git remote add origin2 git@github.com:xxx/learngit-2.git</code></p>
<p>注意这里不再是 <code>origin</code> 而是设置为了 <code>origin2</code> </p>
<p> <img src="/2019/12/28/git/image-20200419130834029.png" alt></p>
<p><em>附：这里不同的远程仓库可以设置到同一个origin里面，这种适用于 一次推送想推送到多个仓库里面去，使用的是git remot里面的 set url指令来设置的。</em></p>
<p><em>但是不推荐这样做，因为一个仓库通常对应的是一个生产或发布的环境，那么就需要把一部分代码推送到正式的仓库中，也有一部分推送到自己或其他人的仓库。</em></p>
<p>然后就可以自己决定代码推送到哪一个远程仓库了</p>
<p><code>git push origin2 master</code></p>
<h1 id="快照管理"><a href="#快照管理" class="headerlink" title="快照管理"></a>快照管理</h1><p><code>git add xx</code> 命令是再工作区内对文件进行管理操作</p>
<p>本地会有一个 git的版本库</p>
<p>首先在本地 有些文件是没有被git仓库进行管理的，也有一些是已经管理过的（或提交过）</p>
<p>这时一个新文件做了一些新功能，就需要通过 <code>git add xx</code>命令添加到 本地版本库中的 临时管理区域(stage)中，这时git就开始监视这个文件了</p>
<p>当做了一次正式的提交操作后 <code>commit</code> ，这个文件就会变成一次快照</p>
<p><em>注：此时快照保存的是 文件的改变，而不是文件本身，否则git仓库会非常非常大</em></p>
<p> <img src="/2019/12/28/git/image-20200419131918056.png" alt></p>
<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p> <img src="/2019/12/28/git/image-20200419132512720.png" alt></p>
<p>可以看到之前的提交，是谁提交的，什么时候提交的，以及提交的日志，很重要</p>
<p>当需要进行 回滚 的时候，需要查看 hash值</p>
<h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p> <img src="/2019/12/28/git/image-20200419132642677.png" alt></p>
<p>主要是本地的提交，包括一些本地删除的提交，如果要撤回删除的提交，就可以使用 <code>git reflog</code>查看 hash值方便回退</p>
<h2 id="git-comfig"><a href="#git-comfig" class="headerlink" title="git comfig"></a>git comfig</h2><p>配置，查看全局配置 ： <code>git config --global --list</code></p>
<p> <img src="/2019/12/28/git/image-20200419133726337.png" alt></p>
<p>user.name 和 user.email 是必须要设置的，否则不能进行提交操作，如果没有设置，可以使用</p>
<p><code>git config --global user.name &quot;example name&quot;</code></p>
<p><code>git config --global user.email &quot;example@xx.com&quot;</code></p>
<h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><p>回退，顺便演示 <code>git log</code> 和 <code>git reflog</code>的区别和使用方法</p>
<p>首先新建 <code>321.txt</code>  并再进行一次新的提交</p>
<p> <img src="/2019/12/28/git/image-20200419133649723.png" alt></p>
<p>使用 <code>git log</code>查看</p>
<p> <img src="/2019/12/28/git/image-20200419133710364.png" alt></p>
<p>然后使用 <code>git reset</code> 命令回退到上一个版本，再使用git log查看时发现新版本就被删除掉了</p>
<p> <img src="/2019/12/28/git/image-20200419133920268.png" alt></p>
<p>但是使用 <code>git reflog</code> 就发现  仍然可以查看本地所有的操作日志</p>
<p> <img src="/2019/12/28/git/image-20200419134051346.png" alt></p>
<h1 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h1><p>创建分支</p>
<p> <img src="/2019/12/28/git/image-20200419134328948.png" alt></p>
<p>这时仍然可以使用 <code>git reflog</code>查看本地所有操作，此时HEAD指向的是 master分支上，后面会多出来一个 dev 分支，这个dev分支前面没有origin，说明此时dev是一个本地分支</p>
<h1 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h1><p>此时进行操作 <code>git checkout dev</code> 切换到了dev分支</p>
<p> <img src="/2019/12/28/git/image-20200419134705141.png" alt></p>
<p><code>git log</code> 只显示了当前指向了dev分支</p>
<p><code>git reflog</code> 则显示了在什么时候切换到的dev分支</p>
<h1 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h1><p>假如修改一下 <code>123.txt</code>，使用 <code>git status</code> 就可以看到已经被监控的<code>123.txt</code>文件被修改的log</p>
<p>此时123的功能还没有开发完，不想提交到master分支上去</p>
<p>就可以使用 <code>git stash</code> </p>
<p> <img src="/2019/12/28/git/image-20200419135437517.png" alt></p>
<p>此时再使用 <code>git status</code> 就会发现变成了一个clean的工作区，而且此时123.txt文件内的修改会清空</p>
<p>这个文件的修改部分去哪了，怎么找回来？</p>
<p>使用 <code>git stash apply</code></p>
<p> <img src="/2019/12/28/git/image-20200419135718052.png" alt></p>
<p>文件就回来了</p>
<p><em>适用场景： 在一个分支上开发过程中，需要去别的分支看一眼，但是如果直接切换分支的话会提示有文件被修改，无法切换分支。这时就可以使用 git stash 把当前分支的状态缓存一下，就可以进行分支的切换了。想恢复就使用 git stash apply</em></p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>想查看当前分支下哪些文件发生了什么变化</p>
<p> <img src="/2019/12/28/git/image-20200419152847535.png" alt></p>
<h1 id="Git-Flow-（重点）"><a href="#Git-Flow-（重点）" class="headerlink" title="Git Flow （重点）"></a>Git Flow （重点）</h1><p>开发环境可能会有 自我测试环境、用户测试alpha、beta环境，正式环境</p>
<p>这里不讨论经典模型的问题</p>
<h2 id="1-适用于持续集成的模型"><a href="#1-适用于持续集成的模型" class="headerlink" title="1. 适用于持续集成的模型"></a>1. 适用于持续集成的模型</h2><p> <img src="/2019/12/28/git/image-20200419153451745.png" alt></p>
<p>在<code>master</code>分支上进行开发提交，一旦到版本需要发布的时候，就把代码合并到 <code>pre-production</code>分支上去，这样就算完成了一次测试提交了（预发布）</p>
<p>如果预发布版本没什么问题，就可以合并到 <code>production</code> 分支上了，production上的代码就自动进行构建</p>
<ul>
<li>适用于持续集成多环境场景</li>
<li>上游分支向下游发展</li>
</ul>
<p>流程：</p>
<p>Bug -&gt; New Branch -&gt; master -&gt; pre branch -&gt; Target Branch</p>
<h2 id="2-类Vue、React的模型"><a href="#2-类Vue、React的模型" class="headerlink" title="2. 类Vue、React的模型"></a>2. 类Vue、React的模型</h2><p> <img src="/2019/12/28/git/image-20200419154036502.png" alt></p>
<p>大家都在master分支上开发，当需要对master分支发布一个比较稳定的版本的时候，直接从master分支上新建一个分支出来，然后在这个分支上进行一些小的BUG修复</p>
<ul>
<li>适用于版本项目</li>
<li>稳定版本从master检出  bug修复在分支</li>
</ul>
<p>流程： master -&gt; Stable -&gt; new branch -&gt; bug fix -&gt;version</p>
<h2 id="演示-Vue的github"><a href="#演示-Vue的github" class="headerlink" title="演示 Vue的github"></a>演示 Vue的github</h2><p> <img src="/2019/12/28/git/image-20200419154417126.png" alt></p>
<p> <img src="/2019/12/28/git/image-20200419154428487.png" alt></p>
<p>Vue的github上，大家都是在dev分支上玩，然后直接从dev分支checkout版本分支出来</p>
<p>好处： 保证稳定的版本</p>
<h1 id="实操-git-flow"><a href="#实操-git-flow" class="headerlink" title="实操 git flow"></a>实操 git flow</h1><p>准备两个本地仓库，remote为同一个远程仓库的origin</p>
<p>拉取远程分支：</p>
<p><code>git pull origin master</code></p>
<p>假设这两个文件夹是两个不同的人在协同开发</p>
<p>那么两个人就需要商定：</p>
<p>每个人都在自己的 <code>dev</code> 分支上玩，<code>git branch</code> 查看分支，<code>git branch dev</code> 创建分支，就从master分支上检出（复制）了一份代码</p>
<p>因为在现实生活中，多人协作的时候，一般来说除了管理员，一般人是没有master分支的推送权限的，只能拉取</p>
<p><em>附： 快速创建并切换分支命令： <code>git checkout -b dev</code></em></p>
<p><em>注意：如果当前分支上有代码修改的话，是不允许切换到其他分支的。这时就需要经常使用 <code>git status</code> 命令查看当前分支的情况</em></p>
<p>现在，两个同事在各自的<code>dev</code>分支上 同时修改了 <code>123.txt</code>， 第一个同事 push 到 dev分支是可以正常推送的</p>
<p> <img src="/2019/12/28/git/image-20200419161047474.png" alt></p>
<p>但是当第一位同事推送过后，第二位同事再进行push，就会出现错误</p>
<p> <img src="/2019/12/28/git/image-20200419161203326.png" alt></p>
<p>提示说 远程的dev分支上已经有了一个<strong>本地尚不存在</strong>的提交</p>
<p>这时有两种方法</p>
<ol>
<li><p>大众做法，根据提示 使用 <code>git pull</code>，会自动执行合并</p>
<p>此时因为两位同事对同一个文件进行了修改，所以肯定会遇到合并冲突</p>
<p> <img src="/2019/12/28/git/image-20200419161449052.png" alt></p>
<p>使用 <code>git status</code> 查看一下状态，说双方都修改了 <code>123.txt</code></p>
<p> <img src="/2019/12/28/git/image-20200419161558245.png" alt></p>
<p>此时打开 <code>123.txt</code>文件，会出现git生成的分隔</p>
<p>上面的HEAD是本地本分支上的代码，下面就是远程代码的变化</p>
<p> <img src="/2019/12/28/git/image-20200419161753260.png" alt></p>
<p>此时修改好内容，保留本地的修改，然后执行 <code>git add 123.txt</code> <code>git commit</code></p>
<p>！ 此时再使用 <code>git status</code> 查看时发现当前是一个干净的分支</p>
<p> <img src="/2019/12/28/git/image-20200419162004499.png" alt></p>
<p>这时再push dev 就可以了</p>
<p> <img src="/2019/12/28/git/image-20200419162037595.png" alt></p>
</li>
<li><p>先进的解决办法 <code>git fetch</code></p>
<p>！ <code>git pull</code>命令相当于是 <code>git fetch</code> + <code>git merge</code></p>
<p><code>git fetch</code>命令只会拉取远程更新，但是不会把远程的更新合并到本地分支里面去。</p>
<p>简单说就是看一下远端分支和我本地分支有什么不一样</p>
<p> <img src="/2019/12/28/git/image-20200419162700091.png" alt></p>
<p>会提示远程有一个更新，现在已经把更新的内容放到了<code>FETCH_HEAD</code>中</p>
<p><code>git merge FETCH_HEAD</code> 就相当于合并两边的代码，就和直接使用 <code>git pull</code> 命令效果一样了。</p>
<p>如果 使用<code>git fetch origin feature:dev1</code> ，意思是把远端的feature分支合并到本地的 dev1分支上，如果dev1不存在，则会自动创建，并且此时 dev1分支上的代码就是 远端feature分支的代码了</p>
<p>此时再切换到 <code>dev</code> 分支上  使用 <code>git merge dev1</code> 就可以把代码合并到dev分支上来了</p>
<p>但是如果感觉远端的代码不好，又不想<code>merge</code>了怎么办？</p>
<p>使用 <code>git reset --hard head^</code> 回退到上一次提交的快照</p>
</li>
</ol>
<h1 id="两种工作流的实际操作"><a href="#两种工作流的实际操作" class="headerlink" title="两种工作流的实际操作"></a>两种工作流的实际操作</h1><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>比如  现在有三个分支 <code>dev</code>  <code>feature</code>  <code>master</code> ， <code>feature</code> 分支为开发分支，<code>dev</code>为预发布分支</p>
<p>现在要把开发分支feature上的代码 发布到预发布分支dev上</p>
<p> <img src="/2019/12/28/git/image-20200421164947264.png" alt></p>
<p>首先使用 <code>git checkout</code> 命令切换到将要合并的分支也就是dev上，然后使用 <code>git merge</code> 命令合并分支上的内容</p>
<p> <img src="/2019/12/28/git/image-20200421165243448.png" alt></p>
<p>如果<code>feature</code> 分支上的内容和 <code>dev</code> 有冲突会提示的，没有冲突就会合并了</p>
<p>现在进行另一个操作： <code>dev</code>分支代码测试完成，需要把预发布分支<code>dev</code> 上的代码发布到正式/生产环境的分支<code>master</code>上</p>
<p>同样的操作，checkout到master分支，然后merge dev分支的代码即可。</p>
<p>注意就是需要 先切换到<strong>需要合并的分支</strong>上，再进行merge。</p>
<p> <img src="/2019/12/28/git/image-20200421165605527.png" alt></p>
<p>至此完成了 场景一 中的Git flow 工作流程。</p>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>第二种 基于版本的Git工作流需要使用一个很重要的概念就是 <code>git tag</code></p>
<p><code>git tag</code> 就是给当前分支的当前这次提交打上一个 tag</p>
<p> <img src="/2019/12/28/git/image-20200421170049950.png" alt></p>
<p><em>注意： 如果像之前一样只使用 <code>git push origin master</code> 推送只会推送代码，不会推送tag。如果想连同tag一起推送就需要在后面添加 <code>--tags</code> 参数</em></p>
<p>那么 添加<code>tag</code> 已经完成了，怎么删除本地tag呢？使用 <code>git tag -d vxxxx</code>删除</p>
<p> <img src="/2019/12/28/git/image-20200421170417469.png" alt></p>
<p>那么怎么删除远程tag呢？ <code>git push origin :refs/tags/v1.0.0</code></p>
<p> <img src="/2019/12/28/git/image-20200421170553813.png" alt></p>
<p>冒号<code>:</code> 代表前面没有任何分支的推送。</p>
<p>同样的，怎么删除远程分支呢？ 这里删除远程dev分支为例。</p>
<p><code>git push origin :dev</code></p>
<p> <img src="/2019/12/28/git/image-20200421170742118.png" alt></p>
<p>下面说一种场景的解决方法</p>
<p>没有完成代码的功能块，但是由于一些原因，把没有完成的功能代码进行了一次提交</p>
<p>本地还好，如果推送到了远程是很不利于code review的</p>
<p>这里除了之前说过的 <code>git stash</code> 缓存代码以外，还可以使用 <code>git reset</code>重置一些不必要的修改</p>
<p>如果使用 <code>git add .</code>  跟踪了不必要的文件：</p>
<p> <img src="/2019/12/28/git/image-20200421171508653.png" alt></p>
<p>git给了提示 使用 <code>git restore --staged &lt;file&gt;</code></p>
<p>另一种方法： 使用 <code>git reset HEAD &lt;file&gt;</code> 取消暂存</p>
<p> <img src="/2019/12/28/git/image-20200421172027861.png" alt></p>
<p>另一个场景：</p>
<p>怎么修改已经添加到版本库里面的文件的修改呢？也就是已经拍了快照的文件。</p>
<p>比如</p>
<p> <img src="/2019/12/28/git/image-20200421172504481.png" alt></p>
<p><code>feature add file.txt</code>文件是已经在版本库中的文件，在里面写了代码，但是感觉不好，怎么抛弃对它的修改？</p>
<p>同样提示 使用 <code>git restore &lt;file&gt;</code> 命令，还有一种方法就是使用 <code>git checkout -- &lt;file&gt;</code> </p>
<p> <img src="/2019/12/28/git/image-20200421172647387.png" alt></p>
<h1 id="Git-Flow-的意义"><a href="#Git-Flow-的意义" class="headerlink" title="Git Flow 的意义"></a>Git Flow 的意义</h1><p> <img src="/2019/12/28/git/image-20200421172955830.png" alt></p>
<h1 id="Branch分支的创建原则"><a href="#Branch分支的创建原则" class="headerlink" title="Branch分支的创建原则"></a>Branch分支的创建原则</h1><p> <img src="/2019/12/28/git/image-20200421173319262.png" alt></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
